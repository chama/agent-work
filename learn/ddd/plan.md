# DDD (Domain-Driven Design) 10日間マスタープラン

> **対象者**: Junior Engineer
> **目標**: DDDの概念を理解し、実際のプロジェクトで適用できるレベルに到達する
> **前提知識**: オブジェクト指向プログラミングの基礎、Web アプリケーション開発の経験

---

## 学習の全体像

```
Day 1-2:  基礎概念の理解（Why & What）
Day 3-4:  戦略的設計（Strategic Design）
Day 5-7:  戦術的設計（Tactical Design）
Day 8-9:  実践プロジェクト（Hands-on）
Day 10:   総復習 & 実務適用の準備
```

---

## Day 1: DDDとは何か — 思想と背景を理解する

### 学習目標
- DDDが解決しようとしている問題を理解する
- ソフトウェアの複雑さの本質を理解する
- DDDの全体像を俯瞰できるようになる

### 学習内容

#### 1. なぜDDDが必要なのか（1.5時間）
- ソフトウェア開発における「本質的複雑さ」と「偶有的複雑さ」
- 技術駆動 vs ドメイン駆動の違い
- 「大きな泥団子（Big Ball of Mud）」アンチパターン
- DDDが生まれた背景（Eric Evans "Domain-Driven Design" 2003年）

#### 2. DDDの全体像（1.5時間）
- 戦略的設計（Strategic Design）と戦術的設計（Tactical Design）の2つの柱
- DDDのパターンカタログ一覧を俯瞰する
- DDDと他の設計手法（クリーンアーキテクチャ、ヘキサゴナルアーキテクチャ）の関係

#### 3. ユビキタス言語（Ubiquitous Language）（2時間）
- ユビキタス言語とは何か、なぜ最も重要な概念なのか
- 開発者とドメインエキスパートの「言葉のズレ」が引き起こす問題
- ユビキタス言語の構築方法と維持方法
- コード内で言語を体現する意味

### 演習
- [ ] 自分が関わったプロジェクトで「技術用語とビジネス用語のズレ」があった事例を3つ書き出す
- [ ] 身近なドメイン（例: ECサイト、図書館管理）を1つ選び、ユビキタス言語の用語集を10個以上作成する

### 推奨リソース
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Part I (Chapter 1-3)
- 書籍: 「ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本」(成瀬允宣) Chapter 1
- 動画: Eric Evans "What I've learned about DDD since the book" (YouTube)

---

## Day 2: ドメインモデルとモデリング

### 学習目標
- ドメインモデルの意味と役割を理解する
- モデリングの考え方を身につける
- 良いモデルと悪いモデルの違いを判断できるようになる

### 学習内容

#### 1. ドメインモデルとは（1.5時間）
- モデルとは「現実の抽象化」であること
- モデルは目的によって異なること（地図のアナロジー）
- ドメインモデル = ドメインの概念を表現するソフトウェアモデル
- ドメインモデル貧血症（Anemic Domain Model）アンチパターン

#### 2. モデリングの技法（2時間）
- ドメインエキスパートとの対話の仕方
- イベントストーミング（Event Storming）の概要
- モデルの継続的な改善（Refactoring Toward Deeper Insight）

#### 3. ドメインモデルをコードで表現する（1.5時間）
- リッチドメインモデル vs 貧血ドメインモデル
- ドメインロジックの置き場所
- コードサンプルの読み解き

### 演習
- [ ] Day 1で選んだドメインについて、ドメインモデル図（クラス図的なもの）を手書きで作成する
- [ ] 「貧血ドメインモデル」のコード例を見て、「リッチドメインモデル」にリファクタリングする
- [ ] イベントストーミングの模擬ワークショップ: 付箋（もしくはMiro）を使って、選んだドメインのイベントを洗い出す

### 推奨リソース
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Chapter 1-3
- 記事: Martin Fowler "AnemicDomainModel" (martinfowler.com)
- 動画: Alberto Brandolini "Event Storming" (YouTube)

---

## Day 3: 境界づけられたコンテキスト（Bounded Context）

### 学習目標
- Bounded Context の概念と必要性を理解する
- コンテキストマップを描けるようになる
- 大規模システムにおけるモデルの分割方法を理解する

### 学習内容

#### 1. Bounded Context（2時間）
- なぜ1つの統一モデルではダメなのか
- Bounded Context = モデルが有効な境界
- 同じ言葉が異なるコンテキストで異なる意味を持つ例
  - 例: 「顧客」は販売コンテキストと配送コンテキストで異なる
  - 例: 「商品」はカタログコンテキストと在庫コンテキストで異なる
- Bounded Context とマイクロサービスの関係

#### 2. コンテキストマップ（Context Map）（2時間）
- コンテキスト間の関係パターン:
  - **Shared Kernel**: 共有部分を持つ
  - **Customer-Supplier**: 上流・下流の関係
  - **Conformist**: 下流が上流に従う
  - **Anti-Corruption Layer (ACL)**: 変換層を設ける
  - **Open Host Service / Published Language**: 公開APIを提供
  - **Separate Ways**: 統合しない
- 実際のシステムのコンテキストマップ例

#### 3. コンテキスト境界の見つけ方（1時間）
- ビジネス組織構造との関係（コンウェイの法則）
- チーム境界との整合
- 技術的関心ではなくビジネス的関心で分割する

### 演習
- [ ] ECサイトを題材に、最低4つのBounded Contextを特定し、図に描く
- [ ] 特定したBounded Context間のコンテキストマップを作成する（関係パターンを明記）
- [ ] 各コンテキストで「注文」「顧客」「商品」がそれぞれどう異なるかを表にまとめる

### 推奨リソース
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Part IV (Chapter 14)
- 書籍: 「実践ドメイン駆動設計」(ヴァーン・ヴァーノン) Chapter 2-3
- 記事: Martin Fowler "BoundedContext" (martinfowler.com)

---

## Day 4: 戦略的設計の深掘り — サブドメインとコアドメイン

### 学習目標
- サブドメインの分類（Core / Supporting / Generic）を理解する
- ビジネス価値に基づいた設計判断ができるようになる
- 戦略的設計の意思決定フレームワークを身につける

### 学習内容

#### 1. サブドメインの分類（2時間）
- **Core Domain（コアドメイン）**: ビジネスの競争優位性の源泉。最も投資すべき領域
- **Supporting Subdomain（支援サブドメイン）**: コアを支えるが、差別化要因ではない
- **Generic Subdomain（汎用サブドメイン）**: どの企業でも共通。既製品やSaaSで代替可能
- 各サブドメインに対する投資戦略の違い
- 実例: Netflixにおけるコアドメイン = レコメンデーション、Generic = 課金

#### 2. コアドメインの蒸留（Distillation）（1.5時間）
- なぜコアドメインを明確にすることが重要か
- Domain Vision Statement の書き方
- Highlighted Core の特定方法
- コアドメインに最高のエンジニアを配置する理由

#### 3. 戦略的設計の意思決定（1.5時間）
- 「作る vs 買う vs 借りる」の判断基準
- ドメインの複雑さに応じたアーキテクチャ選択
- CQRS / Event Sourcing の導入判断基準（概要レベル）

### 演習
- [ ] 自分の会社（または想定企業）のドメインを Core / Supporting / Generic に分類する
- [ ] Domain Vision Statement を1つ書いてみる（200字以内で簡潔に）
- [ ] 「なぜそれがコアドメインなのか」をビジネスの観点から説明する文章を書く

### 推奨リソース
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Chapter 15-16
- 書籍: 「ドメイン駆動設計をはじめよう」(Vlad Khononov) Chapter 1-8
- 記事: "Core Domain Patterns" by Nick Tune

---

## Day 5: エンティティ、値オブジェクト、ドメインサービス

### 学習目標
- Entity, Value Object, Domain Service の違いを正確に理解する
- それぞれをいつ使うべきか判断できるようになる
- コードレベルで実装できるようになる

### 学習内容

#### 1. エンティティ（Entity）（1.5時間）
- 同一性（Identity）で区別されるオブジェクト
- ライフサイクルを持つ
- 同一性の実装方法（ID生成戦略: UUID, DB連番, ドメイン固有ID）
- エンティティの等価性の実装
- 実装例: `User`, `Order`, `Product`

#### 2. 値オブジェクト（Value Object）（2時間）
- 属性の組み合わせで区別されるオブジェクト
- **不変（Immutable）** であること
- 値オブジェクトの等価性（構造的等価性）
- 値オブジェクトのメリット: 副作用の排除、テスト容易性
- いつ値オブジェクトにすべきか（プリミティブ型への執着アンチパターン）
- 実装例: `Money`, `EmailAddress`, `DateRange`, `Address`

#### 3. ドメインサービス（Domain Service）（1.5時間）
- エンティティにも値オブジェクトにも属さないドメインロジック
- ドメインサービスの条件: ステートレス、ドメイン言語で名前がつく
- ドメインサービス vs アプリケーションサービスの違い
- 過剰なドメインサービスの使用（= 貧血ドメインモデルの兆候）
- 実装例: `TransferService`（口座間送金）, `PricingService`

### 演習
- [ ] 以下を実装する（言語は自由。TypeScript or Python推奨）:
  - `Money` 値オブジェクト（通貨と金額を持ち、加算・比較ができる）
  - `EmailAddress` 値オブジェクト（バリデーション付き）
  - `Order` エンティティ（OrderId, OrderLine の追加/削除、合計金額計算）
- [ ] 「これはEntityかValue Objectか？」の判断問題を10問解く
  - 例: 住所は？ → 文脈による（配送先としてはVO、不動産ドメインではEntity）

### 推奨リソース
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Chapter 5-6
- 書籍: 「ドメイン駆動設計入門」(成瀬允宣) Chapter 2-6
- 記事: Martin Fowler "ValueObject" (martinfowler.com)

---

## Day 6: 集約（Aggregate）とリポジトリ（Repository）

### 学習目標
- 集約の設計原則を理解する
- トランザクション境界としての集約を理解する
- リポジトリパターンを実装できるようになる

### 学習内容

#### 1. 集約（Aggregate）（2.5時間）
- 集約 = データ変更の一貫性を保証する境界
- **集約ルート（Aggregate Root）**: 外部からのアクセスの窓口
- 集約の設計原則:
  1. 真の不変条件（ビジネスルール）を集約境界内に閉じ込める
  2. 小さな集約を設計する
  3. 他の集約への参照はIDのみで持つ
  4. 結果整合性（Eventual Consistency）を受け入れる
- 集約を大きくしすぎるアンチパターン
- 集約境界の見つけ方

#### 2. リポジトリ（Repository）（1.5時間）
- リポジトリ = 集約の永続化と取得を担当
- コレクション指向 vs 永続化指向
- リポジトリのインターフェース設計
- リポジトリは集約ルート単位で1つ
- リポジトリとDAO（Data Access Object）の違い

#### 3. ファクトリ（Factory）（1時間）
- 複雑なオブジェクト生成をカプセル化する
- ファクトリメソッド vs ファクトリクラス
- 集約の生成と再構築

### 演習
- [ ] ECサイトの「注文」集約を設計する:
  - 集約ルート: `Order`
  - 内部エンティティ: `OrderLine`
  - 値オブジェクト: `Money`, `Quantity`, `OrderId`
  - 不変条件: 「注文の合計金額は0円以上」「注文明細は1つ以上必要」
- [ ] `OrderRepository` のインターフェースを定義する
- [ ] 「注文に商品を追加する」「注文をキャンセルする」のユースケースを集約メソッドとして実装する

### 推奨リソース
- 書籍: 「実践ドメイン駆動設計」(ヴァーン・ヴァーノン) Chapter 10-12
- 書籍: 「エリック・エヴァンスのドメイン駆動設計」Chapter 6
- 記事: Vaughn Vernon "Effective Aggregate Design" (3部作)

---

## Day 7: ドメインイベント、仕様パターン、アーキテクチャ

### 学習目標
- ドメインイベントの概念と活用方法を理解する
- レイヤードアーキテクチャにおけるDDDの配置を理解する
- 仕様パターンで複雑な条件を表現できるようになる

### 学習内容

#### 1. ドメインイベント（Domain Event）（2時間）
- ドメインイベント = 「ドメインで起きた重要な出来事」
- 命名規則: 過去形で表現する（例: `OrderPlaced`, `PaymentReceived`）
- イベントの発行と購読の仕組み
- イベント駆動アーキテクチャとの関係
- ドメインイベントを使った集約間の連携
- 結果整合性の実現

#### 2. 仕様パターン（Specification Pattern）（1時間）
- 複雑なビジネスルールをオブジェクトとしてカプセル化
- 仕様の組み合わせ（AND, OR, NOT）
- クエリへの応用
- 実装例: `OverdueOrderSpecification`, `PremiumCustomerSpecification`

#### 3. アーキテクチャとDDD（2時間）
- **レイヤードアーキテクチャ**: Presentation → Application → Domain → Infrastructure
- **ヘキサゴナルアーキテクチャ（Ports & Adapters）**: ドメインを中心に据える
- **オニオンアーキテクチャ**: 依存の方向を内側に向ける
- **クリーンアーキテクチャ**: Uncle Bobの円形モデル
- 依存関係逆転の原則（DIP）とDDDの関係
- 各層の責務と依存関係のルール

### 演習
- [ ] Day 6 で作った注文集約に以下を追加:
  - `OrderPlaced` ドメインイベントを発行する仕組み
  - `OrderCancelled` ドメインイベント
- [ ] ヘキサゴナルアーキテクチャのディレクトリ構造を設計し、各フォルダの責務を説明する
- [ ] `OverdueOrderSpecification` を実装し、テストを書く

### 推奨リソース
- 書籍: 「実践ドメイン駆動設計」(ヴァーン・ヴァーノン) Chapter 8, 13
- 記事: Alistair Cockburn "Hexagonal Architecture"
- 記事: "Domain Events" by Martin Fowler (martinfowler.com)

---

## Day 8: 実践プロジェクト（Part 1）— 設計フェーズ

### 学習目標
- Day 1-7 の知識を統合し、実際のアプリケーションの設計に適用する
- 戦略的設計 → 戦術的設計の流れを体験する

### プロジェクト題材: **オンライン書店システム**

#### 1. ドメイン分析（2時間）
- ステークホルダーの特定
- ユビキタス言語の用語集作成
- イベントストーミングの実施（簡易版）
- サブドメインの特定と分類

#### 2. 戦略的設計（1.5時間）
- Bounded Context の特定:
  - カタログコンテキスト
  - 注文コンテキスト
  - 在庫コンテキスト
  - 顧客コンテキスト
  - 決済コンテキスト
- コンテキストマップの作成
- 各コンテキスト間の関係パターンを決定

#### 3. 戦術的設計（1.5時間）
- 注文コンテキストに集中:
  - 集約の設計: `Order`, `Cart`
  - エンティティと値オブジェクトの特定
  - ドメインサービスの特定
  - リポジトリインターフェースの定義
  - ドメインイベントの洗い出し

### 成果物
- [ ] ユビキタス言語の用語集（最低20語）
- [ ] コンテキストマップ（図）
- [ ] 注文コンテキストのドメインモデル図
- [ ] 集約設計書（集約ルート、内部エンティティ、値オブジェクト、不変条件）

---

## Day 9: 実践プロジェクト（Part 2）— 実装フェーズ

### 学習目標
- 設計をコードに落とし込む経験を得る
- テスト駆動でドメインモデルを実装する
- アプリケーション層とインフラ層の実装を体験する

### 実装内容

#### 1. ドメイン層の実装（3時間）
```
src/
├── domain/
│   ├── model/
│   │   ├── order/
│   │   │   ├── Order.ts          # 集約ルート
│   │   │   ├── OrderLine.ts      # 内部エンティティ
│   │   │   ├── OrderId.ts        # 値オブジェクト
│   │   │   ├── OrderStatus.ts    # 値オブジェクト（列挙）
│   │   │   └── OrderEvent.ts     # ドメインイベント
│   │   └── shared/
│   │       ├── Money.ts           # 値オブジェクト
│   │       └── Quantity.ts        # 値オブジェクト
│   ├── repository/
│   │   └── OrderRepository.ts    # インターフェース
│   └── service/
│       └── OrderPricingService.ts # ドメインサービス
```

- 値オブジェクトの実装（不変性、バリデーション、等価性）
- エンティティの実装（ライフサイクル管理、ビジネスルール）
- 集約の実装（不変条件の保証、ドメインイベント発行）
- ドメインサービスの実装

#### 2. アプリケーション層の実装（1時間）
```
src/
├── application/
│   ├── PlaceOrderUseCase.ts
│   ├── CancelOrderUseCase.ts
│   └── AddItemToOrderUseCase.ts
```

- ユースケース（アプリケーションサービス）の実装
- トランザクション管理
- ドメインイベントのディスパッチ

#### 3. インフラ層の実装（1時間）
```
src/
├── infrastructure/
│   ├── persistence/
│   │   └── InMemoryOrderRepository.ts
│   └── event/
│       └── SimpleEventDispatcher.ts
```

- リポジトリの具象クラス（InMemory実装）
- イベントディスパッチャーの実装

### 演習
- [ ] 上記のコードをすべて実装する（テストファースト推奨）
- [ ] 以下のユースケースが動作することを確認:
  1. 新しい注文を作成する
  2. 注文に商品を追加する
  3. 注文を確定する（`OrderPlaced` イベント発行）
  4. 注文をキャンセルする（`OrderCancelled` イベント発行）
- [ ] ドメインの不変条件が破られた場合に適切な例外が投げられることをテストする

---

## Day 10: 総復習 & 実務への適用

### 学習目標
- 10日間の学習を振り返り、知識を定着させる
- DDDを実務に適用するための戦略を立てる
- よくある落とし穴を理解する

### 学習内容

#### 1. 知識の棚卸し（1.5時間）

以下のチェックリストで理解度を確認:

**戦略的設計:**
- [ ] ユビキタス言語の重要性を他人に説明できる
- [ ] Bounded Contextを適切に分割できる
- [ ] コンテキストマップの関係パターンを6つ以上説明できる
- [ ] Core / Supporting / Generic の分類ができる

**戦術的設計:**
- [ ] Entity と Value Object の違いを説明し、適切に使い分けられる
- [ ] 集約の設計原則を4つ言える
- [ ] リポジトリパターンを実装できる
- [ ] ドメインイベントの目的と使い方を説明できる
- [ ] ドメインサービスとアプリケーションサービスの違いを説明できる

**アーキテクチャ:**
- [ ] レイヤードアーキテクチャの各層の責務を説明できる
- [ ] 依存関係逆転の原則とDDDの関係を説明できる

#### 2. よくあるアンチパターンと落とし穴（1.5時間）
- **CRUD思考からの脱却**: 「データの入れ物」ではなく「ビジネスルールの体現」
- **集約を大きくしすぎる**: パフォーマンスとスケーラビリティの問題
- **DDDの過剰適用**: すべてのサブドメインにDDDは不要（Generic は CRUD で十分）
- **技術的関心でのコンテキスト分割**: フロントエンド/バックエンドではなくビジネスドメインで分割
- **ユビキタス言語の軽視**: 最も価値があるのに最もスキップされがち
- **戦略なき戦術**: パターンを使うこと自体が目的化してしまう

#### 3. 実務への適用ステップ（2時間）
1. **既存プロジェクトへの段階的導入**
   - まずユビキタス言語から始める
   - 新機能や大規模リファクタリングのタイミングで導入
   - Anti-Corruption Layer で既存コードとの共存を図る

2. **チームでのDDD推進**
   - ドメインエキスパートとの定期的なモデリングセッション
   - イベントストーミングワークショップの開催
   - コードレビューでドメイン言語の一貫性をチェック

3. **継続的な学習**
   - モデリング力は経験で磨かれる
   - 定期的なモデルの見直しと改善

### 最終課題
- [ ] Day 8-9 のプロジェクトをブラッシュアップし、READMEに設計判断の理由を記述する
- [ ] 「DDDを自分のプロジェクトにどう適用するか」のアクションプランを作成する（具体的なステップ3つ以上）
- [ ] 学んだことを他のチームメンバーに15分で説明するスライドを作成する

---

## 推奨書籍（優先度順）

| 優先度 | 書籍 | 著者 | 特徴 |
|--------|------|------|------|
| ★★★ | ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本 | 成瀬允宣 | 日本語で最も取り組みやすい入門書。コード例が豊富 |
| ★★★ | エリック・エヴァンスのドメイン駆動設計 | Eric Evans | 原典。難解だが必読。辞書的に使うのがおすすめ |
| ★★☆ | 実践ドメイン駆動設計 | Vaughn Vernon | Evans本を実装寄りに解説。集約の設計が特に秀逸 |
| ★★☆ | ドメイン駆動設計をはじめよう | Vlad Khononov | 戦略的設計の解説が充実。比較的新しい書籍 |
| ★☆☆ | マイクロサービスパターン | Chris Richardson | DDDとマイクロサービスの統合的な理解に |

---

## 学習のコツ

1. **手を動かす**: 読書だけでは身につかない。必ずコードを書く
2. **ドメインを決めて一貫して使う**: 複数の題材を使うと混乱する。1つのドメインを深掘りする
3. **完璧を求めない**: DDDは継続的な改善。最初から正解は出ない
4. **戦略的設計を軽視しない**: 戦術的パターン（Entity, VO等）だけがDDDではない。むしろ戦略的設計の方が重要
5. **疑問は即座に言語化する**: 「なぜ？」を常に問い、メンターに質問する
6. **既存コードをDDDの目で見る**: 日常的に「これは Entity？VO？」と考える癖をつける

---

## 10日後のゴール

この10日間を完了した時点で、以下ができるようになっていることを目指す:

- [ ] DDDの主要な概念（戦略的設計・戦術的設計の両方）を正確に説明できる
- [ ] 新規プロジェクトでDDDを適用した設計ができる
- [ ] 既存プロジェクトにDDDを段階的に導入する計画を立てられる
- [ ] ドメインエキスパートと対等にドメインについて議論できる
- [ ] コードレビューでDDDの観点からフィードバックができる

> **メンターへの注記**: 各日の終わりに15分程度の振り返りセッションを設けてください。
> Junior Engineerが「自分の言葉で」その日の学びを説明できるかが、理解度の最も良い指標です。
