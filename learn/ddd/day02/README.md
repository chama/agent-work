# Day 2: ドメインモデルとモデリング

> 「地図は領土ではない」— アルフレッド・コージブスキー
>
> ソフトウェアもまた、現実世界の"地図"である。

---

## 📋 目次

1. [モデルとは何か — 現実の抽象化](#1-モデルとは何か--現実の抽象化)
2. [ドメインモデルとは](#2-ドメインモデルとは)
3. [ドメインモデル貧血症（Anemic Domain Model）](#3-ドメインモデル貧血症anemic-domain-model)
4. [リッチドメインモデル vs 貧血ドメインモデル](#4-リッチドメインモデル-vs-貧血ドメインモデル)
5. [ドメインエキスパートとの対話](#5-ドメインエキスパートとの対話)
6. [イベントストーミング（Event Storming）](#6-イベントストーミングevent-storming)
7. [モデルの継続的な改善](#7-モデルの継続的な改善)
8. [ドメインロジックの置き場所の判断基準](#8-ドメインロジックの置き場所の判断基準)
9. [まとめ](#9-まとめ)
10. [参考文献](#10-参考文献)

---

## 1. モデルとは何か — 現実の抽象化

### 1.1 地図のアナロジー

モデルとは、**現実世界の特定の側面を目的に合わせて抽象化したもの**です。

これを理解するために「地図」のアナロジーを使いましょう。

```
┌─────────────────────────────────────────────────────┐
│                    現実の東京                          │
│                                                       │
│   ビル、人、車、天気、匂い、音、歴史、経済活動...        │
│   → 無限の情報が存在する                               │
└─────────────────────────────────────────────────────┘
          │                    │                │
          ▼                    ▼                ▼
   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
   │   路線図      │  │   地形図      │  │   観光地図    │
   │              │  │              │  │              │
   │ 駅と路線だけ  │  │ 標高と地形    │  │ 名所と経路    │
   │ を抽象化     │  │ だけを抽象化  │  │ だけを抽象化  │
   └──────────────┘  └──────────────┘  └──────────────┘
     目的：移動        目的：地理調査      目的：観光
```

**重要な気づき：**

- **路線図**には「標高」の情報がない → でも電車に乗るには困らない
- **地形図**には「駅」の情報がない → でも地理調査には困らない
- どちらも「東京」を表現しているが、**目的に応じて取捨選択**している

### 1.2 モデルの本質

```
モデル = 現実世界から「目的に必要な情報だけ」を抽出したもの
```

これはソフトウェアにおいても同じです：

```
┌─────────────────────────────────────────┐
│         現実のビジネス領域                 │
│                                           │
│  商慣習、法律、組織文化、暗黙知、          │
│  業務フロー、例外処理、交渉...             │
└─────────────────────────────────────────┘
                    │
                    │ 抽象化（モデリング）
                    ▼
┌─────────────────────────────────────────┐
│         ドメインモデル                     │
│                                           │
│  ソフトウェアで扱う範囲の                  │
│  ビジネスルールと概念を表現                │
└─────────────────────────────────────────┘
```

### 1.3 良いモデルの条件

| 条件 | 説明 | 地図での例 |
|------|------|-----------|
| **目的に合っている** | 解決したい問題に必要な情報がある | 移動なら路線図 |
| **不要な情報がない** | 余分な情報はノイズになる | 路線図に標高は不要 |
| **正確である** | 表現している範囲は現実と一致する | 実在しない駅がない |
| **共通理解を生む** | 関係者全員が同じ理解を持てる | 誰でも路線図を読める |

> **初心者が陥りやすい罠：**
> 「現実を完全にモデル化しよう」とすること。
> 完全なモデルは現実そのものと同じ複雑さを持ち、何の役にも立ちません。
> **「何を省くか」がモデリングの核心です。**

---

## 2. ドメインモデルとは

### 2.1 定義

**ドメインモデル** = ドメイン（業務領域）の概念・ルール・関係性をソフトウェアで表現したもの

```
┌─────────────────────────────────────────────────────────┐
│                    ドメインモデルの構成要素                  │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────────────┐       │
│  │  エンティ  │  │  値オブジ  │  │  ドメインサービス  │       │
│  │  ティ     │  │  ェクト   │  │                  │       │
│  │          │  │          │  │                  │       │
│  │ 固有の    │  │ 値で識別  │  │ エンティティに    │       │
│  │ IDを持つ  │  │ 不変     │  │ 属さない業務     │       │
│  │ オブジェ  │  │          │  │ ロジック         │       │
│  │ クト     │  │          │  │                  │       │
│  └──────────┘  └──────────┘  └──────────────────┘       │
│                                                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────────────┐       │
│  │  集約     │  │  リポジト  │  │  ドメインイベント  │       │
│  │          │  │  リ       │  │                  │       │
│  │ トランザ  │  │          │  │ ドメインで起きた  │       │
│  │ クション  │  │ 永続化の  │  │ 出来事を表す     │       │
│  │ の境界   │  │ 抽象     │  │                  │       │
│  └──────────┘  └──────────┘  └──────────────────┘       │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

### 2.2 ドメインモデルの役割

ドメインモデルは以下の3つの役割を担います：

1. **ビジネスルールの表現**
   - 「注文金額が10,000円以上なら送料無料」
   - 「在庫がない商品は注文できない」

2. **ビジネス概念の構造化**
   - 「注文」は「注文明細」を持つ
   - 「顧客」は「配送先住所」を持つ

3. **チーム内の共通言語（ユビキタス言語）の基盤**
   - コードが業務用語で書かれている → 非エンジニアも読める
   - モデルの変更 = ビジネス理解の深化

### 2.3 ECサイトのドメインモデル例

```
┌──────────────────────────────────────────────┐
│              注文（Order）                      │
│                                                │
│  注文ID                                        │
│  顧客                                          │
│  注文明細リスト ─────┐                          │
│  注文ステータス       │                          │
│  注文日時            │                          │
│                      │                          │
│  + 注文を確定する()   │                          │
│  + 注文をキャンセル() │                          │
│  + 合計金額を計算()   │                          │
└──────────────────────┼──────────────────────────┘
                       │ 1..*
                       ▼
              ┌──────────────────┐
              │ 注文明細           │
              │ (OrderLine)       │
              │                   │
              │  商品              │
              │  数量              │
              │  単価              │
              │                   │
              │  + 小計を計算()    │
              └──────────────────┘
```

---

## 3. ドメインモデル貧血症（Anemic Domain Model）

### 3.1 アンチパターンの定義

**ドメインモデル貧血症**とは、Martin Fowlerが命名したアンチパターンで、
ドメインオブジェクトが**データの入れ物**にすぎず、
ビジネスロジックが**別のサービスクラス**に散らばっている状態を指します。

> "The fundamental horror of this anti-pattern is that it's so contrary to the basic idea of
> object-oriented design; which is to combine data and process together."
> — Martin Fowler

### 3.2 貧血ドメインモデルの構造

```
┌──────────────────────────────────────────────────────────┐
│                貧血ドメインモデルの典型的構造                 │
│                                                            │
│  ┌────────────────────┐       ┌────────────────────────┐  │
│  │    Order クラス      │       │  OrderService クラス    │  │
│  │   （データだけ）      │       │  （ロジックだけ）        │  │
│  │                     │       │                        │  │
│  │  - order_id         │       │  + create_order()      │  │
│  │  - customer_id      │       │  + cancel_order()      │  │
│  │  - items            │  ←──  │  + calculate_total()   │  │
│  │  - status           │  操作  │  + apply_discount()    │  │
│  │                     │       │  + validate_order()    │  │
│  │  + get_order_id()   │       │  + confirm_order()     │  │
│  │  + set_status()     │       │                        │  │
│  │  + get_items()      │       │                        │  │
│  └────────────────────┘       └────────────────────────┘  │
│                                                            │
│  データと振る舞いが分離している → オブジェクト指向の利点を失う   │
└──────────────────────────────────────────────────────────┘
```

### 3.3 なぜ貧血モデルが生まれるのか？

1. **データベース駆動の設計思考**
   - テーブル設計からクラスを自動生成 → getter/setterだけのクラスになる

2. **手続き型プログラミングの習慣**
   - 「データ構造」と「処理」を分けて考える癖

3. **フレームワークの影響**
   - DTO（Data Transfer Object）パターンの過度な適用
   - ORM が生成するモデルクラスをそのまま使う

4. **「ロジックはServiceに書く」という誤解**
   - Service層はドメインロジックの置き場所ではない

### 3.4 貧血モデルの問題点

```
問題1: ビジネスルールの散在
─────────────────────────

OrderService.create_order() で在庫チェック
PaymentService.process_payment() でも在庫チェック
ShippingService.ship_order() でも在庫チェック

→ 同じルールが3箇所に重複！変更時に修正漏れが発生する

問題2: 不正な状態の許容
─────────────────────────

order = Order()
order.status = "shipped"    # まだ支払い前なのに出荷済みにできてしまう！
order.total = -1000         # マイナスの合計金額も設定可能！

→ オブジェクトが自分の整合性を守れない

問題3: コードから業務ルールが読み取れない
─────────────────────────────────────

Order クラスを見ても「注文のルール」がわからない
→ 業務ルールを理解するには Service クラスを全て読む必要がある
→ 新しいメンバーの学習コストが高い
```

### 3.5 具体的なコード比較

詳細なコード例は `examples/anemic_model.py` と `examples/rich_model.py` を参照してください。

---

## 4. リッチドメインモデル vs 貧血ドメインモデル

### 4.1 比較表

| 観点 | 貧血ドメインモデル | リッチドメインモデル |
|------|-------------------|-------------------|
| **データとロジック** | 分離している | 一体化している |
| **ビジネスルール** | Service層に散在 | ドメインオブジェクト内に凝集 |
| **オブジェクトの整合性** | 外部から壊せる | 自分で守る |
| **テストのしやすさ** | Service全体のテストが必要 | オブジェクト単体でテスト可能 |
| **可読性** | ルールを追うのが困難 | クラスを見ればルールがわかる |
| **変更容易性** | 変更の影響範囲が広い | 変更が局所的 |
| **コードの重複** | 発生しやすい | 発生しにくい |

### 4.2 リッチドメインモデルの原則

```
┌─────────────────────────────────────────────────────┐
│           リッチドメインモデルの設計原則                 │
│                                                       │
│  1. Tell, Don't Ask（尋ねるな、命じよ）               │
│     ─────────────────────────────────                 │
│     ✗ if order.status == "confirmed":                │
│           order.status = "shipped"                    │
│                                                       │
│     ✓ order.ship()  # Order自身が状態遷移を管理       │
│                                                       │
│  2. 不変条件の保護                                     │
│     ──────────────                                    │
│     オブジェクトが常に有効な状態であることを保証          │
│     例: 注文金額は0以上、ステータス遷移は正しい順序      │
│                                                       │
│  3. 副作用の明示                                       │
│     ────────────                                      │
│     ドメインイベントで「何が起きたか」を明示する          │
│     例: order.confirm() → OrderConfirmed イベント発行  │
│                                                       │
│  4. ユビキタス言語の反映                                │
│     ──────────────────                                │
│     コードがドメインエキスパートの言葉で書かれている       │
│     例: calculate_total() → 合計金額を算出する         │
│                                                       │
└─────────────────────────────────────────────────────┘
```

### 4.3 状態遷移の比較

```
貧血モデルでの状態遷移（危険！）
────────────────────────────

order.status = "confirmed"   # どこからでも何にでも変更可能
order.status = "invalid"     # 存在しないステータスも設定可能

リッチモデルでの状態遷移（安全！）
────────────────────────────────

order.confirm()    # 下書き → 確定 のみ許可
order.ship()       # 確定 → 出荷済み のみ許可
order.cancel()     # 下書き or 確定 → キャンセル のみ許可

  ┌────────┐  confirm()  ┌────────┐  ship()   ┌──────────┐
  │ 下書き  │ ──────────→│ 確定   │ ────────→│ 出荷済み  │
  │ DRAFT  │            │CONFIRMED│          │ SHIPPED  │
  └────┬───┘            └────┬───┘          └──────────┘
       │                     │
       │     cancel()        │  cancel()
       └──────────┬──────────┘
                  ▼
            ┌──────────┐
            │キャンセル  │
            │CANCELLED │
            └──────────┘
```

---

## 5. ドメインエキスパートとの対話

### 5.1 ドメインエキスパートとは

**ドメインエキスパート** = そのビジネス領域の深い知識を持つ人

- ECサイトなら → 商品企画担当、物流担当、カスタマーサポート担当
- 銀行なら → 融資審査担当、窓口業務担当、リスク管理担当
- 病院なら → 医師、看護師、医事課スタッフ

### 5.2 対話の重要性

```
┌──────────────────────────────────────────────────┐
│                                                    │
│   ドメインエキスパート              開発者           │
│                                                    │
│   「注文がキャンセル     ──→  「status を           │
│    されるときは...」           'cancelled' に       │
│                               すればいいか」        │
│                                                    │
│   「いえ、在庫の戻し    ←──  「あ、在庫の            │
│    と返金処理も                 ロールバックも        │
│    必要ですよ」                 必要なんですね」      │
│                                                    │
│   「それと、出荷済み    ──→  「状態遷移に            │
│    の注文はキャンセル          制約があるんだ...」    │
│    できません」                                     │
│                                                    │
│   → 対話を通じてモデルが深まる                       │
│                                                    │
└──────────────────────────────────────────────────┘
```

### 5.3 効果的な対話テクニック

#### テクニック1: 具体的なシナリオで質問する

```
✗ 悪い質問: 「注文の仕様を教えてください」
  → 抽象的すぎて何を答えればいいかわからない

✓ 良い質問: 「お客様が3つの商品を注文して、1つだけキャンセルしたい場合、
              どういう流れになりますか？」
  → 具体的なシナリオで業務の流れが明確になる
```

#### テクニック2: 「もし〜だったら？」で例外を探る

```
「もし在庫が途中で切れたら、注文全体をキャンセルしますか？
 それとも在庫のある商品だけ出荷しますか？」

→ ビジネスルールの境界条件が明らかになる
```

#### テクニック3: 業務用語をそのまま使う

```
✗ 「このエンティティのステートマシンを定義したいのですが...」
  → ドメインエキスパートに伝わらない

✓ 「注文の状態ってどんな種類がありますか？
     たとえば『下書き』『確定済み』とか...」
  → 業務の言葉で会話する
```

#### テクニック4: 図を一緒に描く

ホワイトボードやMiroなどのツールを使って、
ドメインエキスパートと一緒にモデルを描くことで、
**認識のズレ**を早期に発見できます。

### 5.4 対話から得られるもの

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│ 対話 Round 1  │      │ 対話 Round 2  │      │ 対話 Round 3  │
│              │      │              │      │              │
│ 「注文」は   │  →   │ 「注文」には  │  →   │ 部分キャンセル │
│ 商品のリスト │      │ ステータスが  │      │ という概念が   │
│              │      │ ある         │      │ あるらしい    │
└──────────────┘      └──────────────┘      └──────────────┘

→ モデルは対話の回数を重ねるごとに深くなる（Deeper Insight）
```

---

## 6. イベントストーミング（Event Storming）

### 6.1 イベントストーミングとは

**イベントストーミング**は、Alberto Brandoliniが考案したワークショップ手法で、
ドメインエキスパートと開発者が一緒に**ドメインの振る舞いを可視化**するものです。

```
┌───────────────────────────────────────────────────────────┐
│                 イベントストーミングの概要                    │
│                                                             │
│  参加者: ドメインエキスパート + 開発者 + ファシリテーター     │
│  道具:   広い壁 + 付箋（複数色）+ マーカー                   │
│  時間:   2〜4時間（ビッグピクチャーの場合）                  │
│                                                             │
│  目的:                                                      │
│    ・ドメインの全体像を把握する                               │
│    ・ビジネスプロセスを時系列で可視化する                      │
│    ・境界づけられたコンテキストを発見する                      │
│    ・チーム全体で共通理解を作る                               │
│                                                             │
└───────────────────────────────────────────────────────────┘
```

### 6.2 付箋の色と意味

```
┌────────────────────────────────────────────────────────┐
│                  付箋の種類と色                           │
│                                                          │
│  🟧 オレンジ: ドメインイベント（Domain Event）            │
│     「〜が起きた」「〜された」（過去形で書く）               │
│     例: 「注文が確定された」「支払いが完了した」            │
│                                                          │
│  🟦 ブルー:   コマンド（Command）                        │
│     「〜する」（イベントを引き起こすアクション）             │
│     例: 「注文を確定する」「支払いを処理する」              │
│                                                          │
│  🟨 イエロー: 集約（Aggregate）                          │
│     コマンドを受け取り、イベントを発生させる主体             │
│     例: 「注文」「支払い」「在庫」                         │
│                                                          │
│  🟪 パープル: ポリシー/ビジネスルール                      │
│     イベントに反応して次のコマンドを発行するルール           │
│     例: 「支払い完了時 → 在庫を引き当てる」                │
│                                                          │
│  🟩 グリーン: リードモデル/画面                           │
│     ユーザーが意思決定に使う情報                            │
│     例: 「商品一覧画面」「注文履歴画面」                    │
│                                                          │
│  🟥 レッド:   ホットスポット/疑問点                       │
│     議論が必要な未解決の問題                                │
│     例: 「部分キャンセルの仕様は？」                       │
│                                                          │
│  👤 小さい付箋: アクター（Actor）                         │
│     コマンドを実行する人やシステム                          │
│     例: 「顧客」「管理者」「決済システム」                  │
│                                                          │
└────────────────────────────────────────────────────────┘
```

### 6.3 イベントストーミングの手順

```
Step 1: ドメインイベントの洗い出し（15-20分）
═══════════════════════════════════════════

  全員がオレンジの付箋に「過去形」でイベントを書き出す
  この段階では順番を気にしない（ブレインストーミング）

  例:
  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
  │ 商品がカート  │ │ 注文が確定   │ │ 支払いが     │
  │ に追加された  │ │ された       │ │ 完了した     │
  └──────────────┘ └──────────────┘ └──────────────┘
  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
  │ 商品が出荷   │ │ 注文が       │ │ 在庫が       │
  │ された       │ │ キャンセル   │ │ 引き当て     │
  │              │ │ された       │ │ られた       │
  └──────────────┘ └──────────────┘ └──────────────┘


Step 2: タイムラインに並べる（10-15分）
═════════════════════════════════════

  イベントを時系列に左から右に並べる

  時間 ──────────────────────────────────────────→

  商品がカート  → 注文が   → 支払いが → 在庫が引き → 商品が
  に追加された    確定された  完了した   当てられた   出荷された


Step 3: コマンドとアクターの追加（15-20分）
═══════════════════════════════════════════

  各イベントの原因となるコマンドとアクターを追加

    👤顧客           👤顧客          👤決済システム
      │                │                │
      ▼                ▼                ▼
  ┌────────────┐  ┌────────────┐  ┌────────────┐
  │ カートに    │  │ 注文を     │  │ 支払いを   │
  │ 追加する    │  │ 確定する   │  │ 処理する   │
  │ (Command)  │  │ (Command)  │  │ (Command)  │
  └────────────┘  └────────────┘  └────────────┘
        │                │                │
        ▼                ▼                ▼
  ┌────────────┐  ┌────────────┐  ┌────────────┐
  │ 商品がカート│  │ 注文が確定 │  │ 支払いが   │
  │ に追加された│  │ された     │  │ 完了した   │
  │ (Event)    │  │ (Event)    │  │ (Event)    │
  └────────────┘  └────────────┘  └────────────┘


Step 4: 集約の特定（15-20分）
═══════════════════════════

  コマンドを受け取る「主体」を特定する

  ┌──────────┐    ┌──────────┐    ┌──────────┐
  │  カート   │    │  注文    │    │  支払い   │
  │(Aggregate)│   │(Aggregate)│   │(Aggregate)│
  └──────────┘    └──────────┘    └──────────┘


Step 5: 境界の発見（15-20分）
═══════════════════════════

  関連する集約をグルーピングし、
  境界づけられたコンテキスト（Bounded Context）の候補を発見する

  ┌─ 注文コンテキスト ──────────┐  ┌─ 決済コンテキスト ─┐
  │                              │  │                    │
  │  [カート] ──→ [注文]         │  │  [支払い]          │
  │                              │  │                    │
  └──────────────────────────────┘  └────────────────────┘
```

### 6.4 イベントストーミングの Tips

1. **「正解」を求めない** — 議論のプロセスそのものが価値
2. **全員が付箋を書く** — 発言力の差をなくす
3. **ホットスポット（赤い付箋）を恐れない** — 未解決の問題を可視化する
4. **ファシリテーターは中立** — 答えを出すのではなく、議論を促進する

コード例は `examples/event_storming_example.py` を参照してください。

---

## 7. モデルの継続的な改善

### 7.1 Refactoring Toward Deeper Insight

Eric Evansは「ドメイン駆動設計」の中で、
モデルは**一度作って終わりではなく、継続的に深い洞察に向けてリファクタリングすべき**
と述べています。

```
┌──────────────────────────────────────────────────────────┐
│             モデルの進化プロセス                             │
│                                                            │
│  初期モデル        中期モデル         成熟モデル             │
│  ──────────       ──────────        ──────────             │
│                                                            │
│  ┌──────┐         ┌──────┐         ┌──────────┐           │
│  │ 注文  │         │ 注文  │         │ 注文      │           │
│  │      │   →     │      │   →     │          │           │
│  │金額   │         │金額   │         │ 金額（値） │           │
│  │商品   │         │明細[] │         │ 明細[]    │           │
│  │       │         │合計() │         │ 割引ポリシー│          │
│  └──────┘         └──────┘         │ 合計()    │           │
│                                     │ キャンセル()│          │
│  粗い理解          構造の改善        │ 確定()     │           │
│                                     └──────────┘           │
│                                     ビジネスルールの         │
│                                     カプセル化             │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

### 7.2 ブレイクスルーの瞬間

モデルの改善は徐々に進むこともありますが、
**突然の気づき（ブレイクスルー）** によって劇的に良くなることがあります。

```
モデルの理解度
    ^
    │                                        ┌─── 成熟
    │                                   ┌────┘
    │                              ┌────┘
    │                 ★ブレイクスルー!
    │                ┌─┘
    │            ┌───┘
    │       ┌────┘
    │   ┌───┘
    │───┘
    └──────────────────────────────────────→ 時間

    ★ = 「あ！注文のキャンセルって、実は "返品" と "取消" の
         2つの異なるビジネス概念だったんだ！」
```

### 7.3 モデルを改善するシグナル

以下のような兆候が見られたら、モデルの改善を検討しましょう：

| シグナル | 説明 | 対処 |
|---------|------|------|
| **概念の不一致** | ドメインエキスパートの言葉とコードの用語が違う | ユビキタス言語の見直し |
| **条件分岐の増加** | if-else が多く、読みにくい | ポリモーフィズムの導入 |
| **同じロジックの重複** | 複数箇所で同じルールを実装 | ドメインオブジェクトへの集約 |
| **変更の波及** | 1つの変更が多くのファイルに影響 | 責任の再配置 |
| **テストの困難さ** | 単体テストが書きにくい | 依存関係の整理 |

### 7.4 改善の実践例

```python
# Before: 「割引」が暗黙的な概念
class OrderService:
    def calculate_total(self, order):
        total = sum(item.price * item.quantity for item in order.items)
        if order.customer.is_premium:
            total *= 0.9  # プレミアム会員10%割引
        if total >= 10000:
            total -= 500  # 1万円以上で500円引き
        return total

# After: 「割引ポリシー」を明示的な概念として抽出
class DiscountPolicy:
    """割引ポリシー — ドメインエキスパートとの対話で発見された概念"""
    def calculate_discount(self, order) -> Money:
        raise NotImplementedError

class PremiumMemberDiscount(DiscountPolicy):
    """プレミアム会員割引"""
    def calculate_discount(self, order) -> Money:
        if order.customer.is_premium:
            return order.subtotal * Decimal("0.10")
        return Money.zero()

class BulkOrderDiscount(DiscountPolicy):
    """大口注文割引"""
    def calculate_discount(self, order) -> Money:
        if order.subtotal >= Money(10000):
            return Money(500)
        return Money.zero()
```

この例では、「割引」という**暗黙的な概念**を**明示的なドメインオブジェクト**に変換しています。
これがEvansの言う「Deeper Insight（より深い洞察）」です。

---

## 8. ドメインロジックの置き場所の判断基準

### 8.1 ロジックの分類

ソフトウェアのロジックは大きく3つに分類できます：

```
┌──────────────────────────────────────────────────────────┐
│                 ロジックの3分類                             │
│                                                            │
│  ┌────────────────────────────────────────────────────┐   │
│  │ 1. ドメインロジック（ビジネスロジック）                │   │
│  │    ビジネスルールそのもの                              │   │
│  │    例: 「在庫不足の商品は注文できない」                 │   │
│  │    例: 「合計金額10,000円以上で送料無料」               │   │
│  │    → ドメインモデル（エンティティ/値オブジェクト）に置く │   │
│  └────────────────────────────────────────────────────┘   │
│                                                            │
│  ┌────────────────────────────────────────────────────┐   │
│  │ 2. アプリケーションロジック（ユースケースロジック）     │   │
│  │    ビジネスルールの「調整」や「手順」                   │   │
│  │    例: 「注文確定 → 決済 → 在庫引当 → メール送信」     │   │
│  │    → アプリケーションサービスに置く                     │   │
│  └────────────────────────────────────────────────────┘   │
│                                                            │
│  ┌────────────────────────────────────────────────────┐   │
│  │ 3. インフラロジック（技術的関心事）                     │   │
│  │    技術的な実装の詳細                                  │   │
│  │    例: 「DBへの保存」「メール送信」「外部API呼び出し」   │   │
│  │    → インフラストラクチャ層に置く                       │   │
│  └────────────────────────────────────────────────────┘   │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

### 8.2 判断フローチャート

```
ロジックの置き場所を決める判断フロー
══════════════════════════════════════

                ┌────────────────────────┐
                │ このロジックは何に      │
                │ 関するもの？           │
                └───────────┬────────────┘
                            │
              ┌─────────────┼─────────────┐
              ▼             ▼             ▼
     ┌──────────────┐ ┌──────────┐ ┌──────────────┐
     │ ビジネスルール │ │ 手順の   │ │ 技術的な     │
     │ そのもの？    │ │ 調整？   │ │ 実装詳細？   │
     └──────┬───────┘ └────┬─────┘ └──────┬───────┘
            │              │              │
            ▼              ▼              ▼
  ┌────────────────┐ ┌──────────┐ ┌──────────────┐
  │ 単一の          │ │ アプリケ  │ │ インフラ層    │
  │ エンティティに  │ │ ーション │ │              │
  │ 属するか？      │ │ サービス │ │ Repository   │
  │                │ │          │ │ Gateway      │
  └──┬──────┬──────┘ └──────────┘ │ Adapter      │
     │      │                      └──────────────┘
     ▼      ▼
  Yes│    No│
     │      │
     ▼      ▼
┌────────┐┌──────────────┐
│ エンティ ││ ドメイン      │
│ ティの  ││ サービス      │
│ メソッド ││              │
│        ││ 複数の集約に  │
│        ││ またがるロジック│
└────────┘└──────────────┘
```

### 8.3 具体例で考える

```
例1: 「注文の合計金額を計算する」
→ Orderエンティティに属するロジック
→ Order.calculate_total() メソッド

例2: 「注文を確定する（在庫チェック → 決済 → 確認メール送信）」
→ 複数の関心事の調整 = アプリケーションロジック
→ OrderApplicationService.confirm_order() メソッド
  （内部で Order.confirm() + PaymentGateway.charge() + Mailer.send() を呼ぶ）

例3: 「2つの注文の合計金額を比較する」
→ 単一エンティティに属さないドメインロジック
→ ドメインサービス

例4: 「注文データをDBに保存する」
→ 技術的な実装詳細
→ OrderRepository.save()

例5: 「プレミアム会員なら10%割引」
→ ビジネスルール → ドメインロジック
→ DiscountPolicy ドメインオブジェクト or Order.apply_discount()
```

### 8.4 よくある間違い

```
❌ 間違い1: 全部 Service に書く
─────────────────────────────
「ロジックは Service に書くもの」という思い込み
→ 貧血ドメインモデルの原因

❌ 間違い2: ドメインモデルに技術的関心事を混ぜる
────────────────────────────────────────────
class Order:
    def save(self):
        db.execute("INSERT INTO orders ...")  # ❌ インフラの関心事！

→ ドメインモデルはビジネスロジックだけに集中すべき

❌ 間違い3: アプリケーションロジックとドメインロジックの混同
───────────────────────────────────────────────────────
class OrderService:
    def confirm_order(self, order_id):
        order = self.repo.find(order_id)
        if order.total >= 10000:         # ← これはドメインロジック！
            order.shipping_fee = 0       #    Order に移動すべき
        order.status = "confirmed"
        self.repo.save(order)
        self.mailer.send(order)

→ ビジネスルール（送料計算）はドメインモデルへ
→ 手順の調整（取得→確定→保存→通知）はアプリケーションサービスへ
```

### 8.5 レイヤーごとの責務まとめ

```
┌──────────────────────────────────────────────────┐
│               プレゼンテーション層                  │
│   HTTP リクエストの受付、レスポンスの返却           │
│   入力のバリデーション（形式チェック）               │
├──────────────────────────────────────────────────┤
│               アプリケーション層                    │
│   ユースケースの調整（手順の管理）                  │
│   トランザクション管理                              │
│   ドメインオブジェクトの取得と保存の指示             │
├──────────────────────────────────────────────────┤
│               ドメイン層                            │
│   ★ ビジネスルールの表現                           │
│   ★ ドメインオブジェクト（エンティティ、値オブジェクト）│
│   ★ ドメインサービス                               │
│   ★ ドメインイベント                               │
├──────────────────────────────────────────────────┤
│               インフラストラクチャ層                 │
│   DB アクセス（Repository実装）                    │
│   外部API呼び出し                                  │
│   メール送信                                       │
│   ファイルI/O                                      │
└──────────────────────────────────────────────────┘
```

---

## 9. まとめ

### 今日学んだこと

```
┌─────────────────────────────────────────────────────┐
│                  Day 2 のまとめ                       │
│                                                       │
│  1. モデルとは現実の抽象化                             │
│     → 目的に合わせて必要な情報だけを抽出する           │
│                                                       │
│  2. ドメインモデル = ビジネスの概念をコードで表現       │
│     → データ + ビジネスルール = リッチドメインモデル    │
│                                                       │
│  3. 貧血ドメインモデルはアンチパターン                 │
│     → データだけのクラス + ロジックだらけのService      │
│     → ビジネスルールの散在、不正な状態の許容           │
│                                                       │
│  4. ドメインエキスパートとの対話が不可欠               │
│     → 具体的なシナリオで質問                          │
│     → 業務用語を使う                                  │
│                                                       │
│  5. イベントストーミングは強力なモデリング手法          │
│     → イベント → コマンド → 集約 の順で発見           │
│                                                       │
│  6. モデルは継続的に改善する                           │
│     → 暗黙的な概念を明示的にする                      │
│     → ブレイクスルーの瞬間がある                      │
│                                                       │
│  7. ロジックの置き場所には判断基準がある               │
│     → ドメイン / アプリケーション / インフラ を区別    │
│                                                       │
└─────────────────────────────────────────────────────┘
```

### 次回予告

**Day 3: エンティティと値オブジェクト**
- エンティティの同一性とライフサイクル
- 値オブジェクトの不変性と等価性
- 実装パターンとベストプラクティス

---

## 10. 参考文献

- Eric Evans 著「Domain-Driven Design: Tackling Complexity in the Heart of Software」
- Martin Fowler「AnemicDomainModel」 https://martinfowler.com/bliki/AnemicDomainModel.html
- Vaughn Vernon 著「Implementing Domain-Driven Design」
- Alberto Brandolini「Introducing EventStorming」
- Scott Wlaschin 著「Domain Modeling Made Functional」
