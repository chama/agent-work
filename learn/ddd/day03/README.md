# Day 3: 境界づけられたコンテキスト（Bounded Context）

> **学習目標**:
> - Bounded Context の概念と必要性を理解する
> - コンテキストマップを描けるようになる
> - 大規模システムにおけるモデルの分割方法を理解する

> **所要時間**: 約5時間
> **前提知識**: Day 1（ユビキタス言語）, Day 2（ドメインモデル）を修了していること

---

## 目次

1. [なぜ1つの統一モデルではダメなのか](#1-なぜ1つの統一モデルではダメなのか)
2. [Bounded Context とは何か](#2-bounded-context-とは何か)
3. [同じ言葉が異なるコンテキストで異なる意味を持つ](#3-同じ言葉が異なるコンテキストで異なる意味を持つ)
4. [Bounded Context とマイクロサービスの関係](#4-bounded-context-とマイクロサービスの関係)
5. [コンテキストマップ（Context Map）](#5-コンテキストマップcontext-map)
6. [コンテキスト境界の見つけ方](#6-コンテキスト境界の見つけ方)
7. [コンウェイの法則との関係](#7-コンウェイの法則との関係)
8. [チーム境界との整合](#8-チーム境界との整合)
9. [まとめ](#9-まとめ)
10. [推奨リソース](#10-推奨リソース)

---

## 1. なぜ1つの統一モデルではダメなのか

### 理想と現実のギャップ

DDDを学び始めたとき、多くの人が考えることがあります。

> 「ドメインモデルを1つ作って、システム全体で共有すればいいじゃないか」

一見合理的に思えるこの発想は、**小規模なシステムでは機能しますが、システムが成長するにつれて必ず破綻します**。

### 具体例: ECサイトの「商品」

ECサイトを構築しているとしましょう。「商品（Product）」はシステムの中心的な概念です。
1つの `Product` クラスでシステム全体をカバーしようとすると、こうなります:

```
最初はシンプルだった Product クラス
┌──────────────────────────────────┐
│ Product                          │
│──────────────────────────────────│
│ id                               │
│ name                             │
│ price                            │
│──────────────────────────────────│
│ getPrice()                       │
└──────────────────────────────────┘

        ↓ 半年後 ↓

┌──────────────────────────────────────────────────────┐
│ Product (God Object)                                 │
│──────────────────────────────────────────────────────│
│ id, name, description, price, tax_rate,              │
│ discount_price, campaign_price,                      │ ← カタログチームが追加
│ images[], categories[], tags[],                      │
│ stock_quantity, warehouse_location,                  │ ← 在庫チームが追加
│ reorder_point, safety_stock,                         │
│ weight, dimensions, shipping_class,                  │ ← 配送チームが追加
│ is_hazardous, customs_code,                          │
│ supplier_id, cost_price, lead_time,                  │ ← 仕入チームが追加
│ review_score, review_count,                          │ ← レビューチームが追加
│ seo_title, seo_description,                          │ ← マーケチームが追加
│──────────────────────────────────────────────────────│
│ getPrice(), getDiscountedPrice(),                    │
│ calculateTax(), checkStock(),                        │
│ reserveStock(), calculateShipping(),                 │
│ getSupplierInfo(), getReviews(),                     │
│ generateSeoMeta(), ...                               │
│ （40個以上のメソッド）                                  │
└──────────────────────────────────────────────────────┘
```

### この「God Model」がもたらす問題

| 問題 | 具体的な影響 |
|------|------------|
| **認知負荷の爆発** | 開発者が Product クラスの全容を把握できない |
| **変更の副作用** | 在庫チームの変更がカタログ表示を壊す |
| **デプロイの結合** | 1つの変更で全チームのテストが必要 |
| **命名の衝突** | `price` はどの価格？定価？割引価格？仕入原価？ |
| **ルールの矛盾** | カタログでは「下書き」状態が必要、在庫では「入荷待ち」が必要 |
| **スケーラビリティ** | 全コンテキストが同じDBテーブルを参照してロック競合 |

### Eric Evans の言葉

> "Total unification of the domain model for a large system will not be feasible or cost-effective."
>
> （大規模システムにおけるドメインモデルの完全な統一は、実現不可能であるか、コスト的に見合わない）
>
> — Eric Evans, "Domain-Driven Design"

この認識こそが、Bounded Context が必要な根本的な理由です。

---

## 2. Bounded Context とは何か

### 定義

**Bounded Context（境界づけられたコンテキスト）** とは:

> **特定のドメインモデルが適用される明確な境界**

もう少し噛み砕くと:

- **あるモデル（用語・ルール・構造）が一貫した意味を持つ範囲**のこと
- その境界の内側では、ユビキタス言語が**矛盾なく**定義される
- 境界の外側では、同じ言葉が異なる意味を持ってよい

### 図で理解する

```
┌─────────────────────────────────────────────────────────────┐
│                     ECサイト全体                              │
│                                                             │
│  ┌──────────────────┐    ┌──────────────────┐               │
│  │ カタログコンテキスト │    │ 在庫コンテキスト    │               │
│  │                  │    │                  │               │
│  │  Product:        │    │  Product:        │               │
│  │   - name         │    │   - sku          │               │
│  │   - description  │    │   - quantity     │               │
│  │   - price        │    │   - location     │               │
│  │   - images       │    │   - reorder_point│               │
│  │                  │    │                  │               │
│  │  Category        │    │  Warehouse       │               │
│  │  Brand           │    │  StockMovement   │               │
│  └──────────────────┘    └──────────────────┘               │
│                                                             │
│  ┌──────────────────┐    ┌──────────────────┐               │
│  │ 注文コンテキスト    │    │ 配送コンテキスト    │               │
│  │                  │    │                  │               │
│  │  Product:        │    │  Product:        │               │
│  │   - name         │    │   - weight       │               │
│  │   - unit_price   │    │   - dimensions   │               │
│  │   - quantity     │    │   - is_fragile   │               │
│  │                  │    │                  │               │
│  │  Order           │    │  Shipment        │               │
│  │  OrderLine       │    │  DeliveryRoute   │               │
│  └──────────────────┘    └──────────────────┘               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**ポイント**: 各コンテキスト内の `Product` は、そのコンテキストに必要な属性だけを持ちます。
これは「同じクラスの重複」ではなく、「異なる概念の正確な表現」です。

### Bounded Context の3つの側面

```
                    ┌───────────────────────┐
                    │   Bounded Context     │
                    │                       │
         ┌─────────┼───────────┐           │
         │ 言語の境界 │           │           │
         │ (Language)│ モデルの境界│           │
         │         │ (Model)   │           │
         │         │           │ 実装の境界  │
         │         │           │ (Code)    │
         └─────────┼───────────┘           │
                    │                       │
                    └───────────────────────┘
```

1. **言語の境界**: 同じ用語が明確な意味を持つ範囲（ユビキタス言語のスコープ）
2. **モデルの境界**: ドメインモデル（エンティティ、値オブジェクト等）が有効な範囲
3. **実装の境界**: コードベース、データベース、デプロイ単位の範囲

---

## 3. 同じ言葉が異なるコンテキストで異なる意味を持つ

これは Bounded Context を理解する上で**最も重要なポイント**です。

### 例1: 「顧客（Customer）」

```
販売コンテキスト                    配送コンテキスト
┌──────────────────────┐          ┌──────────────────────┐
│ Customer             │          │ Customer             │
│──────────────────────│          │──────────────────────│
│ id                   │          │ id                   │
│ name                 │          │ name                 │
│ email                │          │ delivery_address     │
│ purchase_history     │          │ phone_number         │
│ loyalty_rank         │          │ delivery_preference  │
│ credit_limit         │          │ access_instructions  │
│──────────────────────│          │──────────────────────│
│ calculateDiscount()  │          │ getOptimalRoute()    │
│ upgradeRank()        │          │ isAvailableAt()      │
│ checkCreditLimit()   │          │ getDeliveryWindow()  │
└──────────────────────┘          └──────────────────────┘

販売チームにとっての「顧客」:           配送チームにとっての「顧客」:
→ 購買力のある存在                    → 届け先の存在
→ ロイヤルティランクが重要              → 住所と配達時間が重要
→ 信用枠の管理が必要                  → アクセス方法の情報が必要
```

販売コンテキストの `Customer` は「いくら買ってくれるか」が関心事です。
配送コンテキストの `Customer` は「どこにどう届けるか」が関心事です。

**同じ「顧客」という言葉でも、見ている世界がまったく違います。**

### 例2: 「商品（Product）」

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  カタログコンテキスト          在庫コンテキスト                      │
│  ┌─────────────────┐        ┌─────────────────┐                │
│  │ 商品 = 魅力的に   │        │ 商品 = 管理する   │                │
│  │ 見せるもの        │        │ 在庫のもの        │                │
│  │                 │        │                 │                │
│  │ ・商品名         │        │ ・SKU番号        │                │
│  │ ・説明文         │        │ ・在庫数量        │                │
│  │ ・画像一覧       │        │ ・保管場所        │                │
│  │ ・価格           │        │ ・発注点          │                │
│  │ ・カテゴリ        │        │ ・安全在庫        │                │
│  │ ・ブランド        │        │ ・入荷予定日      │                │
│  │ ・レビュー       │        │ ・ロット番号      │                │
│  └─────────────────┘        └─────────────────┘                │
│                                                                 │
│  注文コンテキスト              会計コンテキスト                      │
│  ┌─────────────────┐        ┌─────────────────┐                │
│  │ 商品 = 注文に含   │        │ 商品 = 収益計算   │                │
│  │ まれる明細行      │        │ の対象            │                │
│  │                 │        │                 │                │
│  │ ・商品名         │        │ ・勘定科目        │                │
│  │ ・単価           │        │ ・原価            │                │
│  │ ・数量           │        │ ・売上単価        │                │
│  │ ・小計           │        │ ・税区分          │                │
│  │ ・割引額         │        │ ・利益率          │                │
│  └─────────────────┘        └─────────────────┘                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 例3: 「注文（Order）」

| コンテキスト | 「注文」の意味 | 関心事 |
|---|---|---|
| **販売** | 顧客が購入を確定した取引 | 合計金額、支払い方法、割引 |
| **在庫** | 在庫を引き当てる指示 | 引当数量、倉庫、ピッキング |
| **配送** | 届けるべき荷物のまとまり | 届け先、重量、配送方法 |
| **会計** | 売上として計上すべき取引 | 売上額、原価、利益 |
| **カスタマーサポート** | 問い合わせの対象となった取引 | ステータス、履歴、返品可否 |

このように、**同じ「注文」でも5つのコンテキストで5つの異なるモデル**が存在するのが自然です。

### 重要な気づき

> **コンテキストを分けることは「DRY原則の違反」ではない。**
>
> DRY原則（Don't Repeat Yourself）は「同じ知識の重複を避ける」原則です。
> しかし、異なるコンテキストの `Product` は **異なる知識** を表現しています。
> これを無理に統合することこそが、設計上の誤りです。

---

## 4. Bounded Context とマイクロサービスの関係

### よくある誤解

> 「Bounded Context = マイクロサービスですよね？」

**答え: 必ずしもそうではありません。** ただし、強い関連があります。

### 関係性の整理

```
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  Bounded Context は「論理的な境界」                             │
│  → ドメインモデルが有効な範囲を定義する                           │
│  → 組織・ビジネスの視点から決まる                                │
│                                                              │
│  マイクロサービスは「物理的な境界」                               │
│  → デプロイ・実行の単位を定義する                                │
│  → 技術・運用の視点から決まる                                   │
│                                                              │
│  理想: Bounded Context とマイクロサービスが 1:1 で対応            │
│  現実: 1つの Bounded Context が複数のサービスに分かれることもある  │
│        1つのサービスが複数の Bounded Context を含むこともある      │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### パターン別の解説

```
パターン1: 1 BC = 1 マイクロサービス（理想的）
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ カタログBC    │    │  在庫BC      │    │  注文BC      │
│ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────────┐ │
│ │Service A│ │    │ │Service B│ │    │ │Service C│ │
│ └─────────┘ │    │ └─────────┘ │    │ └─────────┘ │
└─────────────┘    └─────────────┘    └─────────────┘

パターン2: 1 BC = 複数サービス（BCが大きい場合）
┌──────────────────────────────────┐
│ 注文BC                           │
│ ┌──────────┐ ┌────────────────┐ │
│ │注文受付    │ │ 注文処理        │ │
│ │Service    │ │ Service        │ │
│ └──────────┘ └────────────────┘ │
└──────────────────────────────────┘

パターン3: 1 サービス = 複数BC（モノリス初期段階）
┌──────────────────────────────────┐
│ モノリシックサービス                  │
│ ┌───────────┐ ┌────────────────┐│
│ │カタログBC   │ │ 在庫BC         ││
│ │(module)   │ │ (module)       ││
│ └───────────┘ └────────────────┘│
└──────────────────────────────────┘
  ※ Modular Monolith パターン
```

### 実務上のアドバイス

**「まずモノリスで始め、Bounded Context を意識してモジュール分割し、必要に応じてマイクロサービスに切り出す」**

これが現在の業界のベストプラクティスです。いきなりマイクロサービスに分割するのではなく:

1. **Modular Monolith** で Bounded Context ごとにモジュールを分ける
2. 各モジュール間は**明確なインターフェース**でのみ通信する
3. スケーラビリティや独立デプロイが必要になったモジュールから**段階的に切り出す**

---

## 5. コンテキストマップ（Context Map）

### コンテキストマップとは

Bounded Context を特定したら、次に考えるべきは**コンテキスト間の関係**です。
**コンテキストマップ**は、複数の Bounded Context がどのように関係し、統合するかを示す図です。

Eric Evans は、コンテキスト間の関係を6つのパターンに分類しました。

```
コンテキストマップの全体像

┌──────────────────────────────────────────────────────┐
│                                                      │
│   統合パターン（Integration Patterns）                  │
│                                                      │
│   ├── 協調的関係                                      │
│   │   ├── Shared Kernel（共有カーネル）                 │
│   │   └── Customer-Supplier（顧客・供給者）             │
│   │                                                  │
│   ├── 従属的関係                                      │
│   │   ├── Conformist（従属者）                         │
│   │   └── Anti-Corruption Layer（腐敗防止層）           │
│   │                                                  │
│   ├── 公開的関係                                      │
│   │   └── Open Host Service / Published Language      │
│   │       （公開ホストサービス / 公表された言語）          │
│   │                                                  │
│   └── 非統合                                         │
│       └── Separate Ways（別々の道）                    │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

### パターン1: Shared Kernel（共有カーネル）

#### 概要

2つの Bounded Context が**ドメインモデルの一部を共有**するパターンです。

```
         ┌──────────────────────────────────────┐
         │                                      │
         │  ┌────────────┐  ┌────────────┐      │
         │  │            │  │            │      │
         │  │  コンテキスト│  │  コンテキスト│      │
         │  │     A      │  │     B      │      │
         │  │            │  │            │      │
         │  │     ┌──────┼──┼──────┐     │      │
         │  │     │Shared│  │Kernel│     │      │
         │  │     │      │  │      │     │      │
         │  │     └──────┼──┼──────┘     │      │
         │  │            │  │            │      │
         │  └────────────┘  └────────────┘      │
         │                                      │
         └──────────────────────────────────────┘
```

#### 特徴

- 共有部分のコード変更には**両チームの合意**が必要
- 共有部分は**最小限**に保つべき
- 共有するのは「核心的で安定した概念」に限る

#### ユースケース

- **Money（通貨）** を複数コンテキストで共有する
- **共通のドメインイベント定義**を共有する
- 密接に協力する2つのチーム間で使う

#### 注意点

> ⚠️ Shared Kernel は **最もリスクの高い**パターンの1つです。
> 共有部分が大きくなると、実質的に「1つの巨大なコンテキスト」に戻ってしまいます。
> 使う場合は、共有範囲を厳格に管理してください。

---

### パターン2: Customer-Supplier（顧客・供給者）

#### 概要

上流（Supplier / 供給者）と下流（Customer / 顧客）の関係です。
上流が提供するものを、下流が利用します。

```
  ┌──────────────┐         ┌──────────────┐
  │              │         │              │
  │   上流(U)     │────────→│   下流(D)     │
  │  Supplier    │  提供    │  Customer    │
  │              │         │              │
  │  例: 在庫     │         │  例: 注文     │
  │  コンテキスト  │         │  コンテキスト  │
  │              │         │              │
  └──────────────┘         └──────────────┘
        │                        │
        │  上流は下流の要求を       │
        │  考慮してAPIを設計する    │
        └────────────────────────┘
```

#### 特徴

- 上流チームが**下流チームの要求を聞く義務**がある
- 下流チームは上流チームに**フィードバック**を提供する
- 両者の間に**交渉のプロセス**が存在する

#### ユースケース

- 注文コンテキスト（下流）が在庫コンテキスト（上流）に在庫確認を依頼
- 決済コンテキスト（下流）が会員コンテキスト（上流）に会員情報を要求

#### 上流チームの責任

```
上流チームがすべきこと:
  ✓ 下流チームの要求を定期的にヒアリングする
  ✓ API変更時は下流チームに事前通知する
  ✓ 後方互換性を維持する努力をする
  ✓ 下流チームのためにテストを提供する
```

---

### パターン3: Conformist（従属者）

#### 概要

上流と下流の関係だが、**上流が下流の要求を考慮しない**パターンです。
下流は上流のモデルに**そのまま従う**しかありません。

```
  ┌──────────────┐         ┌──────────────┐
  │              │         │              │
  │   上流(U)     │────────→│   下流(D)     │
  │  （支配的）    │ 一方的  │  （従属的）    │
  │              │         │              │
  │  例: 外部決済  │         │  例: 自社     │
  │  プロバイダ    │         │  ECサイト     │
  │              │         │              │
  └──────────────┘         └──────────────┘
        │
        │  上流は下流の要求を
        │  考慮しない / できない
        │
        └── 「使いたければ、そのまま使え」
```

#### 特徴

- 上流が**圧倒的に強い立場**にある
- 下流は上流のモデルを**そのまま受け入れる**
- 変換ロジックを書かない（書くなら ACL パターンへ）

#### ユースケース

- **外部SaaS**のAPI（Stripe、AWS等）をそのまま使う場合
- 社内でも**大規模な基幹システム**に小さなチームが従う場合
- **標準規格**（ISO、業界標準フォーマット）に従う場合

#### Customer-Supplier との違い

| | Customer-Supplier | Conformist |
|---|---|---|
| **交渉** | 下流が上流に要求できる | 下流に交渉権がない |
| **上流の姿勢** | 下流の要求を考慮する | 下流を考慮しない |
| **モデルの適合** | 双方で調整する | 下流が一方的に合わせる |

---

### パターン4: Anti-Corruption Layer（腐敗防止層、ACL）

#### 概要

外部コンテキスト（特にレガシーシステム）のモデルが自分のコンテキストに**侵食してくるのを防ぐ**ための変換層です。

```
  ┌──────────────┐    ┌─────────┐    ┌──────────────┐
  │              │    │  ACL    │    │              │
  │  外部/レガシー │    │ ┌─────┐ │    │  自コンテキスト│
  │  コンテキスト  │───→│ │変換  │ │───→│              │
  │              │    │ │ロジック│ │    │  クリーンな   │
  │  汚いモデル    │    │ └─────┘ │    │  ドメインモデル│
  │              │    │         │    │              │
  └──────────────┘    └─────────┘    └──────────────┘

                      ↑ ここが ACL
                      ・外部モデルを自分のモデルに変換
                      ・外部の変更が内部に波及するのを防ぐ
                      ・Adapter パターン + Facade パターン
```

#### 特徴

- **変換層**を設けて、外部のモデルを自コンテキストのモデルに翻訳する
- 外部システムの変更が自コンテキストに**直接影響しない**
- Conformist と違い、自分のモデルの**純粋さを守る**

#### ACL の構成要素

```
ACL の典型的な実装構造

┌─────────────────────────────────────────┐
│  Anti-Corruption Layer                  │
│                                         │
│  ┌─────────────┐  ┌──────────────────┐  │
│  │  Adapter     │  │  Translator      │  │
│  │  (通信)      │  │  (変換)           │  │
│  │             │  │                  │  │
│  │ REST/gRPC/  │  │ 外部モデル →      │  │
│  │ MQ Client   │  │ 自ドメインモデル   │  │
│  └─────────────┘  └──────────────────┘  │
│                                         │
│  ┌─────────────────────────────────┐    │
│  │  Facade                         │    │
│  │  (簡潔なインターフェース)           │    │
│  └─────────────────────────────────┘    │
│                                         │
└─────────────────────────────────────────┘
```

#### ユースケース

- **レガシーシステム**との連携（最も典型的）
- **外部API**との統合で、自分のモデルを守りたい場合
- **段階的なリプレース**（Strangler Fig パターン）の実装

#### 実装例

`examples/anti_corruption_layer.py` に具体的な実装例があります。

---

### パターン5: Open Host Service / Published Language（公開ホストサービス / 公表された言語）

#### 概要

あるコンテキストが**明確に定義されたプロトコル**（公開API）を提供し、
他の複数のコンテキストがそれを利用できるようにするパターンです。

```
                    ┌───────────────────┐
                    │ Open Host Service │
                    │                   │
  ┌──────────┐     │  ┌─────────────┐  │     ┌──────────┐
  │コンテキストA│────→│  │ 公開API     │  │←────│コンテキストC│
  └──────────┘     │  │ (REST/gRPC) │  │     └──────────┘
                    │  │             │  │
  ┌──────────┐     │  │ Published   │  │     ┌──────────┐
  │コンテキストB│────→│  │ Language    │  │←────│コンテキストD│
  └──────────┘     │  │ (JSON/XML)  │  │     └──────────┘
                    │  └─────────────┘  │
                    │                   │
                    │  例: 認証サービス   │
                    └───────────────────┘
```

#### 特徴

- **1つのサービスが多数のクライアントに対応**する
- API仕様（Published Language）が**明確に文書化**されている
- 個別のクライアントの要求に合わせてAPIを変更しない
- OpenAPI (Swagger)、Protocol Buffers、GraphQL Schema などで定義

#### ユースケース

- **認証・認可サービス**（全コンテキストが利用）
- **通知サービス**（メール、Push通知等）
- **マスターデータ管理**（商品マスタ、顧客マスタの提供）
- **公開API**（外部パートナーへのAPI提供）

#### Published Language の例

```
Published Language = 共通の通信フォーマット

例: 商品情報の公開フォーマット（JSON Schema）

{
  "productId": "string (UUID)",
  "name": "string",
  "sku": "string",
  "price": {
    "amount": "number",
    "currency": "string (ISO 4217)"
  },
  "status": "enum: [active, discontinued, draft]"
}

→ このフォーマットが「公表された言語」
→ 利用者はこのフォーマットに基づいて実装する
```

---

### パターン6: Separate Ways（別々の道）

#### 概要

**統合しない**という選択です。2つのコンテキストは独立して動作します。

```
  ┌──────────────┐         ┌──────────────┐
  │              │         │              │
  │  コンテキストA │    ✕    │  コンテキストB │
  │              │  統合    │              │
  │              │  しない  │              │
  │              │         │              │
  └──────────────┘         └──────────────┘

  → 各自が必要なデータを独自に管理
  → 重複があってもOK
  → 統合コストが便益を上回る場合に選択
```

#### 特徴

- 統合の**コストが便益を上回る**と判断した場合
- 完全に**独立したライフサイクル**で開発・運用
- データの重複は**意図的に許容**する

#### ユースケース

- **社内の独立した業務システム**（営業支援と経理システム）
- **地域ごとに異なるシステム**（日本法人とUS法人）
- **一時的なキャンペーンシステム**（メインシステムと統合不要）

#### 統合しない勇気

> 「統合しなくてよいものを無理に統合するのは、最大のムダである」

すべてをつなげたくなる誘惑に抵抗することも、アーキテクトの重要な判断です。

---

### 6つのパターンの比較まとめ

```
統合の強さ（強 ←──────────────────→ 弱）

Shared     Customer    Open Host    Conformist    ACL      Separate
Kernel     Supplier    Service                             Ways
  ■■■■■     ■■■■        ■■■         ■■           ■          □

  密結合 ←──────────────────────────────────→ 疎結合 ──→ 非統合
```

| パターン | 関係性 | チーム間の力関係 | 典型的な状況 |
|---|---|---|---|
| **Shared Kernel** | 対等・協調 | 対等 | 同じチームまたは密接なチーム |
| **Customer-Supplier** | 上流・下流 | 上流が協力的 | 社内チーム間の協調 |
| **Conformist** | 上流・下流 | 上流が支配的 | 外部サービスの利用 |
| **ACL** | 上流・下流 | 下流が自衛 | レガシー連携 |
| **OHS/PL** | 1対多 | 提供者が標準化 | プラットフォームの提供 |
| **Separate Ways** | 無関係 | 独立 | 統合不要と判断 |

---

## 6. コンテキスト境界の見つけ方

### 「どこで分けるか」が最も難しい

Bounded Context の概念を理解しても、実際に「どこに境界を引くか」は難しい問題です。
以下のヒューリスティクス（発見的手法）が役立ちます。

### ヒューリスティクス1: 言語の違いに注目する

```
同じ言葉が異なる意味で使われている場所 = 境界の候補

「この『ユーザー』って、ログインユーザーのこと？
 それとも管理画面のユーザーのこと？」

→ 認証コンテキストと管理コンテキストの境界が見える
```

**実践方法**:
1. ドメインエキスパートとの会話で、同じ言葉に異なる定義が出てきたら境界の兆候
2. 用語集を作成し、複数の意味を持つ用語をリストアップする
3. Event Storming のワークショップで自然に現れる「色分け」を観察する

### ヒューリスティクス2: ビジネスプロセスの変化点

```
受注プロセスの流れ:

[商品を探す] → [カートに入れる] → [注文確定] → [決済] → [出荷] → [配送]

    カタログ        注文             決済       在庫/出荷   配送
    コンテキスト     コンテキスト      コンテキスト コンテキスト コンテキスト

    ↑ プロセスの「手渡しポイント」が境界の候補
```

### ヒューリスティクス3: データの一貫性の境界

**同じトランザクションで更新すべきデータ**は同じコンテキストに属する可能性が高い。

```
注文を確定する → 在庫を引き当てる → 決済を実行する

Q: これらは1つのトランザクションであるべきか？

A: NO! これらは異なるコンテキストの操作。
   → 結果整合性（Eventual Consistency）で統合する
   → Saga パターンやイベント駆動で調整する
```

### ヒューリスティクス4: チーム構造を観察する

（詳細は次のセクション「コンウェイの法則」で解説）

### ヒューリスティクス5: 変更の頻度と理由

```
「一緒に変更されることが多いコード」= 同じコンテキスト
「異なるタイミング・理由で変更されるコード」= 異なるコンテキスト

例:
  ・商品の説明文変更（マーケ起因）→ カタログコンテキスト
  ・在庫の安全在庫変更（物流起因）→ 在庫コンテキスト
  → これらは異なる理由で変更される → 別のコンテキスト
```

---

## 7. コンウェイの法則との関係

### コンウェイの法則とは

> "Organizations which design systems are constrained to produce designs
>  which are copies of the communication structures of these organizations."
>
> （システムを設計する組織は、その組織のコミュニケーション構造を
>  そのまま反映した設計を生み出すことを余儀なくされる）
>
> — Melvin E. Conway, 1967

**簡単に言うと**: 「ソフトウェアの構造は、それを作る組織の構造を鏡のように映す」

### 具体例

```
組織構造:
┌─────────┐  ┌─────────┐  ┌─────────┐
│フロントエンド│  │バックエンド│  │  DBA    │
│  チーム    │  │  チーム   │  │  チーム  │
└─────────┘  └─────────┘  └─────────┘

↓ コンウェイの法則が作用すると... ↓

システム構造（技術レイヤーで分割）:
┌─────────────────────────────────┐
│          フロントエンド            │
├─────────────────────────────────┤
│          バックエンドAPI           │
├─────────────────────────────────┤
│          データベース              │
└─────────────────────────────────┘

→ 技術レイヤーごとの分割（DDDが推奨しない分割方法）
```

### 逆コンウェイの法則（Inverse Conway Maneuver）

**DDDが推奨するのは、この法則を「逆手に取る」アプローチです。**

> 望ましいソフトウェアアーキテクチャに合わせて、組織構造を変える

```
理想のシステム構造（Bounded Context で分割）:
┌───────────┐  ┌───────────┐  ┌───────────┐
│ カタログBC  │  │  注文BC    │  │  配送BC    │
└───────────┘  └───────────┘  └───────────┘

↓ 逆コンウェイの法則を適用 ↓

組織構造を合わせる:
┌───────────┐  ┌───────────┐  ┌───────────┐
│ カタログ    │  │  注文      │  │  配送      │
│ チーム      │  │  チーム    │  │  チーム     │
│ (FE+BE+DB) │  │ (FE+BE+DB)│  │ (FE+BE+DB) │
└───────────┘  └───────────┘  └───────────┘

→ 各チームがフルスタックでBCを担当（クロスファンクショナルチーム）
```

### なぜこれが重要なのか

```
技術レイヤーで分割した場合:
  商品ページの変更 → FEチーム + BEチーム + DBAチーム の3チーム調整が必要
  → コミュニケーションコストが高い
  → 変更速度が遅い

Bounded Context で分割した場合:
  商品ページの変更 → カタログチームだけで完結
  → コミュニケーションコストが低い
  → 変更速度が速い（チームの自律性）
```

---

## 8. チーム境界との整合

### 「1チーム = 1 Bounded Context」の原則

理想的には、**1つの Bounded Context は1つのチームが所有する**べきです。

```
推奨:
┌─────────────────┐    ┌─────────────────┐
│ チームA          │    │ チームB          │
│ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │    BC 1     │ │    │ │    BC 2     │ │
│ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘

避けたい:
┌───────────────────────────────────────┐
│ チームA                               │
│ ┌─────────────┐  ┌─────────────┐     │
│ │    BC 1     │  │    BC 2     │     │ ← 1チームが2つのBCを持つ
│ └─────────────┘  └─────────────┘     │    → 認知負荷が高い
└───────────────────────────────────────┘

もっと避けたい:
     ┌─────────────────────────┐
     │         BC 1            │
     │                         │
┌────┼──────┐         ┌───────┼────┐
│ チームA    │         │  チームB    │    ← 2チームが1つのBCを共有
│    │      │         │       │    │    → 変更の調整が複雑
└────┼──────┘         └───────┼────┘
     │                         │
     └─────────────────────────┘
```

### Team Topologies との関係

近年の「Team Topologies」（Matthew Skelton & Manuel Pais）の考え方と
Bounded Context は非常に相性が良いです。

```
Team Topologies のチームタイプ:

1. Stream-aligned Team（ストリーム整合チーム）
   → Bounded Context を所有する主要チーム
   → ビジネス価値の流れに沿って組織される

2. Platform Team（プラットフォームチーム）
   → 共通基盤を Open Host Service として提供
   → 認証、ログ、監視等のインフラ

3. Enabling Team（イネーブリングチーム）
   → 他チームの技術的課題を支援
   → DDD導入支援、アーキテクチャコンサル

4. Complicated Subsystem Team（複雑サブシステムチーム）
   → 専門的な知識が必要なBC を担当
   → 機械学習、暗号化、金融計算等
```

### チーム境界を決める際の考慮事項

| 考慮事項 | 説明 |
|---|---|
| **認知負荷** | 1つのチームが理解・保守できる範囲に収める |
| **デプロイ独立性** | チームが独立してリリースできるようにする |
| **ドメイン知識** | チームが担当ドメインの深い知識を蓄積できるようにする |
| **コミュニケーション** | チーム間のコミュニケーションパスを最小化する |
| **チームサイズ** | 「Two-Pizza Team」（5-9人）を目安にする |

### 実務での段階的アプローチ

```
Phase 1: コンテキストの発見
  → Event Storming でコンテキスト候補を洗い出す
  → ドメインエキスパートと言語の境界を確認する

Phase 2: コンテキストマップの作成
  → コンテキスト間の関係パターンを特定する
  → 依存関係と統合方針を決める

Phase 3: チーム編成の調整
  → コンテキストに合わせてチームを再編する
  → 各チームに必要なスキルセットを確保する

Phase 4: 段階的な実装
  → Modular Monolith でモジュール分割する
  → 必要に応じてマイクロサービスに切り出す
```

---

## 9. まとめ

### 本日の学びのポイント

```
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  1. 統一モデルの限界                                       │
│     → 大規模システムでは1つのモデルで全てを表現できない        │
│                                                          │
│  2. Bounded Context = モデルの有効範囲                     │
│     → 同じ言葉が異なる意味を持つ → 境界が必要               │
│                                                          │
│  3. コンテキストマップ6パターン                              │
│     → Shared Kernel, Customer-Supplier, Conformist,       │
│       ACL, OHS/PL, Separate Ways                         │
│                                                          │
│  4. 境界の見つけ方                                         │
│     → 言語の違い、プロセスの変化点、データ一貫性の範囲         │
│                                                          │
│  5. 組織とアーキテクチャ                                    │
│     → コンウェイの法則を逆手に取る                           │
│     → 1チーム = 1 Bounded Context が理想                   │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### Day 2 からのつながり

- Day 2 で学んだ「ドメインモデル」は、Bounded Context の**中で**定義される
- ユビキタス言語は Bounded Context の**スコープ内で**有効
- つまり、Bounded Context はユビキタス言語とドメインモデルの**コンテナ**

### Day 4 への橋渡し

Day 4 では、Bounded Context の内部構造を掘り下げます:
- **集約（Aggregate）** によるデータの一貫性境界
- **ドメインイベント** によるコンテキスト間の連携
- **リポジトリパターン** による永続化の抽象化

---

## 10. 推奨リソース

### 書籍

- 「エリック・エヴァンスのドメイン駆動設計」Part IV: Strategic Design（Chapter 14-16）
- 「実践ドメイン駆動設計」（ヴァーン・ヴァーノン） Chapter 2, 3
- 「ドメイン駆動設計入門」（成瀬允宣） Chapter 13-14
- 「Team Topologies」（Matthew Skelton & Manuel Pais）

### 記事・動画

- Martin Fowler: "BoundedContext" (martinfowler.com)
- Eric Evans: "Getting Started with DDD when Surrounded by Legacy Systems" (YouTube)
- Vaughn Vernon: "Strategic Design with Bounded Contexts and the Context Map" (YouTube)

### 実践ツール

- Miro / FigJam: コンテキストマップの作図
- Event Storming: コンテキストの発見ワークショップ

---

> **次回予告**: Day 4 では「集約（Aggregate）とドメインイベント」を学びます。
> Bounded Context の内部で、どのようにデータの整合性を保つかを深掘りします。
