# Day 1: DDDとは何か — 思想と背景を理解する

> **目標**: ドメイン駆動設計（DDD）がなぜ生まれたのか、何を解決しようとしているのかを理解し、
> 最も重要な概念である「ユビキタス言語」の意義を体感する。

---

## 目次

1. [DDDが解決しようとしている問題](#1-dddが解決しようとしている問題)
2. [本質的複雑さと偶有的複雑さ](#2-本質的複雑さと偶有的複雑さ)
3. [技術駆動 vs ドメイン駆動](#3-技術駆動-vs-ドメイン駆動)
4. [大きな泥団子（Big Ball of Mud）](#4-大きな泥団子big-ball-of-mud)
5. [DDDが生まれた背景](#5-dddが生まれた背景)
6. [戦略的設計と戦術的設計 — DDDの2つの柱](#6-戦略的設計と戦術的設計--dddの2つの柱)
7. [DDDパターンカタログ一覧](#7-dddパターンカタログ一覧)
8. [DDDと他の設計手法の関係](#8-dddと他の設計手法の関係)
9. [ユビキタス言語とは何か](#9-ユビキタス言語とは何か)
10. [言葉のズレが引き起こす問題](#10-言葉のズレが引き起こす問題)
11. [ユビキタス言語の構築と維持](#11-ユビキタス言語の構築と維持)
12. [コード内で言語を体現する](#12-コード内で言語を体現する)
13. [まとめ](#13-まとめ)
14. [参考文献](#14-参考文献)

---

## 1. DDDが解決しようとしている問題

### ソフトウェア開発でよくある失敗

あなたはこんな経験がないだろうか？

- 仕様書を読んでもビジネスの意図がわからない
- 既存コードを読んでも「なぜこうなっているのか」が理解できない
- 開発者同士でも同じ言葉に対して違う理解をしている
- ビジネス側の要求が「技術的に正しく」実装されたはずなのに、実際には的外れだった
- システムが大きくなるにつれて、変更が恐ろしく難しくなった

これらの問題の根本原因は**「ビジネスの問題領域（ドメイン）を正しく理解・表現していないこと」**にある。

### DDDの核心的な主張

> **ソフトウェアの最大の敵は「技術的な難しさ」ではなく、「ドメインの複雑さ」である。**

DDDは、この問題に対して以下のアプローチを提案する：

```
┌─────────────────────────────────────────────────┐
│              DDDの基本的な考え方                    │
│                                                   │
│  1. ドメイン（業務領域）を深く理解する               │
│  2. その理解を「共通の言語」で表現する               │
│  3. その言語をそのままコードに反映する               │
│  4. ドメインの構造に従ってシステムを分割する          │
│                                                   │
│  → ビジネスとコードの間のギャップを最小化する         │
└─────────────────────────────────────────────────┘
```

---

## 2. 本質的複雑さと偶有的複雑さ

### Fred Brooks "No Silver Bullet" (1986)

コンピュータ科学者 Fred Brooks は、有名な論文「銀の弾丸はない（No Silver Bullet）」で、
ソフトウェア開発の複雑さを2種類に分類した。

```
ソフトウェアの複雑さ
├── 本質的複雑さ（Essential Complexity）
│   └── 問題領域そのものに内在する複雑さ
│       例: 税法の複雑なルール、保険の査定ロジック
│       → 取り除くことができない
│
└── 偶有的複雑さ（Accidental Complexity）
    └── 技術的な選択によって生まれる複雑さ
        例: フレームワークの制約、DB設計の都合
        → 技術の進歩や設計の改善で軽減できる
```

### 具体例で考える

**ECサイトの「注文」を考えてみよう：**

| 本質的複雑さ（避けられない） | 偶有的複雑さ（減らせる） |
|---|---|
| 在庫引当のタイミング | ORMのN+1問題 |
| キャンセル時の返金計算ルール | DBトランザクションの管理 |
| 税率の切り替え（軽減税率） | APIのバージョニング |
| ポイント付与の条件分岐 | キャッシュの整合性 |

### DDDとの関係

DDDは**本質的複雑さに正面から向き合う**ための手法である。

多くの開発者は偶有的複雑さ（フレームワーク、DB、インフラ）に時間を費やしがちだが、
ビジネスの成功を決めるのは**本質的複雑さをいかに正しくモデル化するか**にかかっている。

> 💡 **Brooks の主張**: 本質的複雑さは魔法のように消し去ることはできない。
> 我々にできるのは、それを**明確に表現し、管理可能にすること**だけだ。
> DDDはまさにそのためのアプローチである。

---

## 3. 技術駆動 vs ドメイン駆動

### 技術駆動の設計（よくある悪い例）

技術駆動の設計では、DBのテーブル構造やフレームワークの都合が設計の出発点になる。

```python
# 技術駆動の例: 技術用語だらけのコード
class UserDao:
    def insert_record(self, data: dict):
        """レコードをINSERTする"""
        self.db.execute("INSERT INTO tbl_users ...", data)

    def update_flag(self, user_id: int, flag: int):
        """フラグを更新する"""
        self.db.execute("UPDATE tbl_users SET status_flag = ?", flag)

    def select_by_condition(self, condition: dict):
        """条件でSELECTする"""
        ...
```

**問題点:**
- `insert_record` → ビジネス的に何をしているのか？ 会員登録？ 仮登録？
- `update_flag` → フラグ=1は何を意味する？ 有効化？ 退会？
- `select_by_condition` → どんな条件？ ビジネスルールは？

### ドメイン駆動の設計（DDDの例）

ドメイン駆動では、ビジネスの言葉がそのままコードに表れる。

```python
# ドメイン駆動の例: ビジネス用語がそのままコードになる
class MemberRegistrationService:
    def register_new_member(self, application: MemberApplication):
        """新規会員を登録する"""
        member = Member.create_from_application(application)
        member.verify_email()
        self.member_repository.save(member)

    def withdraw_member(self, member_id: MemberId):
        """会員を退会処理する"""
        member = self.member_repository.find_by_id(member_id)
        member.withdraw()
        self.member_repository.save(member)

    def find_active_members(self) -> list[Member]:
        """有効な会員を検索する"""
        return self.member_repository.find_active()
```

**改善点:**
- `register_new_member` → 「新規会員登録」という業務がすぐわかる
- `withdraw_member` → 「退会」という概念が明確
- `find_active_members` → 「有効な会員」というドメイン概念

### 比較図

```
┌─────────────────────────────────────────────────────────┐
│                  技術駆動の設計                            │
│                                                          │
│  ビジネス要件 ──→ DB設計 ──→ CRUD操作 ──→ API            │
│                                                          │
│  「DBにどう入れるか」が出発点                               │
│  ビジネスロジックはControllerやServiceに散らばる             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                  ドメイン駆動の設計                        │
│                                                          │
│  ビジネス要件 ──→ ドメインモデル ──→ 実装詳細              │
│                                                          │
│  「ビジネスをどう表現するか」が出発点                       │
│  ビジネスロジックはドメインモデルに集約される                 │
└─────────────────────────────────────────────────────────┘
```

> 📁 詳しいコード例は `examples/tech_driven.py` と `examples/domain_driven.py` を参照。

---

## 4. 大きな泥団子（Big Ball of Mud）

### アンチパターンの説明

「大きな泥団子（Big Ball of Mud）」とは、1997年に Brian Foote と Joseph Yoder が命名した
アンチパターンで、**構造がなく、場当たり的に成長したシステム**を指す。

### 特徴

```
┌─────────────────────────────────────────────────┐
│           大きな泥団子の特徴                       │
│                                                   │
│  ✗ モジュール間の境界が曖昧                        │
│  ✗ どこからでも何でも参照できる                     │
│  ✗ ビジネスロジックがUIやDBコードに混在              │
│  ✗ 同じロジックが複数箇所にコピペされている           │
│  ✗ 変更の影響範囲が予測できない                     │
│  ✗ 新しい開発者が理解するのに数ヶ月かかる            │
└─────────────────────────────────────────────────┘
```

### なぜ泥団子になるのか？

```
初期: きれいなコード
  │
  ├── 「とりあえず動けばいい」という判断
  ├── 締め切りのプレッシャー
  ├── ドメイン知識の不足
  ├── 設計原則の共有不足
  │
  ▼
中期: 少し複雑だが何とかなる
  │
  ├── 既存コードに合わせた妥協
  ├── 「前もこう書いてあったから」
  ├── リファクタリングの時間がない
  │
  ▼
末期: 大きな泥団子
  │
  └── 「触ったら壊れる」
      「誰もこのコードを理解していない」
      「書き直したほうが早い（でもできない）」
```

### DDDは泥団子の予防策

DDDが提供する**境界づけられたコンテキスト（Bounded Context）**は、
システムを意味のある単位に分割し、泥団子化を防ぐ。
これについては Day 3 以降で詳しく学ぶ。

---

## 5. DDDが生まれた背景

### Eric Evans と "Domain-Driven Design" (2003)

DDDは、Eric Evans が2003年に出版した書籍
**"Domain-Driven Design: Tackling Complexity in the Heart of Software"**
（通称「エヴァンス本」または「青い本」）で体系化された。

### 歴史的な流れ

```
1986  Fred Brooks "No Silver Bullet"
      └── 本質的複雑さ vs 偶有的複雑さの概念

1995  GoF "Design Patterns"
      └── オブジェクト指向の設計パターンの体系化

1997  "Big Ball of Mud" 論文
      └── 無秩序な設計のアンチパターンを命名

1999  Martin Fowler "Refactoring"
      └── コードの継続的な改善手法

2002  Martin Fowler "Patterns of Enterprise Application Architecture"
      └── エンタープライズアプリの設計パターン

2003  Eric Evans "Domain-Driven Design"  ★
      └── ドメインモデリングを中心とした設計手法を体系化

2013  Vaughn Vernon "Implementing Domain-Driven Design"
      └── DDDの実践的な実装方法（通称「赤い本」）

2016  Vaughn Vernon "Domain-Driven Design Distilled"
      └── DDDのエッセンスをコンパクトにまとめた入門書
```

### Evans が提起した問題

Evans は長年のコンサルティング経験から、以下の問題に気づいた：

1. **開発者はドメインを軽視しがち**: 「技術的にかっこいい」設計を追求するが、
   ビジネス要件を正しく反映していない
2. **ドメインエキスパートと開発者の断絶**: 両者がまったく異なる言葉を使い、
   認識のズレがバグや手戻りの原因になる
3. **モデルとコードの乖離**: 設計書に書いたモデルと実際のコードが別物になる

これらを解決するために、DDDという統合的な設計アプローチを提案した。

---

## 6. 戦略的設計と戦術的設計 — DDDの2つの柱

DDDは大きく分けて**2つの設計レベル**を提供する。

```
┌─────────────────────────────────────────────────────────────┐
│                    DDD の 2つの柱                             │
│                                                              │
│  ┌─────────────────────────┐  ┌────────────────────────────┐ │
│  │   戦略的設計              │  │    戦術的設計               │ │
│  │   (Strategic Design)     │  │    (Tactical Design)       │ │
│  │                          │  │                            │ │
│  │  「大きな構造」を扱う      │  │  「個々の実装」を扱う       │ │
│  │                          │  │                            │ │
│  │  • 境界づけられた         │  │  • エンティティ             │ │
│  │    コンテキスト           │  │  • 値オブジェクト           │ │
│  │  • コンテキストマップ      │  │  • 集約                   │ │
│  │  • ユビキタス言語         │  │  • ドメインイベント         │ │
│  │  • サブドメイン           │  │  • リポジトリ              │ │
│  │                          │  │  • ドメインサービス         │ │
│  │  【いつ・どこに適用？】    │  │  【どう実装する？】         │ │
│  └─────────────────────────┘  └────────────────────────────┘ │
│                                                              │
│  ★ 戦略的設計のほうがROIが高い（特に大規模システム）            │
│    → Day 1〜3 で戦略的設計を先に学ぶ理由                      │
└─────────────────────────────────────────────────────────────┘
```

### 戦略的設計（Strategic Design）

**「何を作るか」「どう分割するか」**を決める、マクロレベルの設計。

| パターン | 概要 |
|---|---|
| **ユビキタス言語** | チーム全体で共有する共通言語 |
| **境界づけられたコンテキスト** | モデルが有効な範囲を明確にする境界 |
| **コンテキストマップ** | コンテキスト間の関係を可視化する地図 |
| **サブドメイン** | ビジネスドメインの分割単位 |

### 戦術的設計（Tactical Design）

**「具体的にどう実装するか」**を決める、ミクロレベルの設計。

| パターン | 概要 |
|---|---|
| **エンティティ** | 一意のIDを持ち、ライフサイクルがある |
| **値オブジェクト** | IDを持たず、値の等価性で比較する |
| **集約** | 整合性を保つ単位 |
| **ドメインイベント** | ドメインで起きた出来事を表す |
| **リポジトリ** | 集約の永続化を抽象化する |
| **ファクトリ** | 複雑なオブジェクト生成をカプセル化する |
| **ドメインサービス** | エンティティに属さないドメインロジック |

> **重要**: 多くの初学者は戦術的パターン（Entity, Value Object等）に飛びつきがちだが、
> **戦略的設計のほうがプロジェクト成功への影響が大きい**。
> このカリキュラムでは戦略的設計を先に学ぶ。

---

## 7. DDDパターンカタログ一覧

DDDに登場する主要なパターンを俯瞰しよう。今日はすべてを理解する必要はない。
「こんなパターンがあるんだ」という地図を持つことが目的だ。

```
DDDパターンカタログ
│
├── 【戦略的パターン】
│   ├── ユビキタス言語 (Ubiquitous Language)        ← Day 1 ★今日
│   ├── 境界づけられたコンテキスト (Bounded Context)  ← Day 3
│   ├── コンテキストマップ (Context Map)             ← Day 3
│   ├── サブドメイン (Subdomain)                    ← Day 2
│   │   ├── コアドメイン (Core Domain)
│   │   ├── サポートサブドメイン (Supporting)
│   │   └── 汎用サブドメイン (Generic)
│   │
│   └── コンテキスト間の関係パターン
│       ├── 共有カーネル (Shared Kernel)
│       ├── 顧客・供給者 (Customer-Supplier)
│       ├── 順応者 (Conformist)
│       ├── 腐敗防止層 (Anti-Corruption Layer)
│       ├── 公開ホストサービス (Open Host Service)
│       └── 公表された言語 (Published Language)
│
├── 【戦術的パターン】
│   ├── エンティティ (Entity)                       ← Day 5
│   ├── 値オブジェクト (Value Object)                ← Day 5
│   ├── 集約 (Aggregate)                           ← Day 6
│   ├── 集約ルート (Aggregate Root)                  ← Day 6
│   ├── ドメインイベント (Domain Event)              ← Day 7
│   ├── リポジトリ (Repository)                     ← Day 8
│   ├── ファクトリ (Factory)                        ← Day 8
│   ├── ドメインサービス (Domain Service)             ← Day 7
│   └── 仕様 (Specification)
│
└── 【アーキテクチャパターン】
    ├── レイヤードアーキテクチャ                      ← Day 9
    ├── ヘキサゴナルアーキテクチャ                     ← Day 9
    ├── CQRS                                       ← Day 10
    └── イベントソーシング                            ← Day 10
```

---

## 8. DDDと他の設計手法の関係

DDDは孤立した手法ではなく、他の設計手法と**補完的な関係**にある。

### クリーンアーキテクチャとの関係

```
┌──────────────────────────────────────────────────────┐
│                クリーンアーキテクチャ                    │
│                                                       │
│    ┌───────────────────────────────────────────┐      │
│    │          Frameworks & Drivers              │      │
│    │    ┌───────────────────────────────┐       │      │
│    │    │     Interface Adapters         │       │      │
│    │    │    ┌───────────────────┐       │       │      │
│    │    │    │   Use Cases        │       │       │      │
│    │    │    │  ┌───────────┐    │       │       │      │
│    │    │    │  │ Entities  │    │       │       │      │
│    │    │    │  │ (Domain)  │◄───┼── DDDのドメインモデル │
│    │    │    │  └───────────┘    │       │       │      │
│    │    │    └───────────────────┘       │       │      │
│    │    └───────────────────────────────┘       │      │
│    └───────────────────────────────────────────┘      │
│                                                       │
│  依存の方向: 外側 → 内側（内側は外側を知らない）          │
└──────────────────────────────────────────────────────┘

DDDが提供するもの: 中心の「Entities (Domain)」をどうモデリングするか
クリーンアーキテクチャが提供するもの: 各層の依存関係のルール
```

**関係性:**
- **DDD** = ドメイン層を「どう設計するか」（What）
- **クリーンアーキテクチャ** = 各層を「どう配置するか」（How）

### ヘキサゴナルアーキテクチャ（ポート＆アダプタ）との関係

```
              ┌─────────────────────────┐
     HTTP ────┤                         ├──── DB
              │    ┌───────────────┐    │
     CLI ─────┤    │               │    ├──── 外部API
              │    │   ドメイン     │    │
   Message ───┤    │   モデル       │    ├──── ファイル
    Queue     │    │  (DDDの領域)   │    │     システム
              │    └───────────────┘    │
     Test ────┤                         ├──── メール
              │     ポート＆アダプタ      │     サービス
              └─────────────────────────┘
```

**関係性:**
- **DDD** = 中心のドメインモデルの設計方法論
- **ヘキサゴナル** = ドメインを外部の技術詳細から隔離するアーキテクチャ

### まとめ：相互補完の関係

```
┌──────────────────────────────────────────────┐
│                                               │
│   DDD: 「何をモデル化するか」を教えてくれる     │
│   ├── クリーンアーキテクチャ: 層の配置ルール     │
│   ├── ヘキサゴナル: ドメインの隔離方法           │
│   └── CQRS/ES: 読み書きの分離・履歴管理        │
│                                               │
│   → DDDは「考え方」、他は「構造」を提供する      │
│   → 組み合わせて使うことで最大の効果を発揮する    │
│                                               │
└──────────────────────────────────────────────┘
```

---

## 9. ユビキタス言語とは何か

### DDDで最も重要な概念

**ユビキタス言語（Ubiquitous Language）**は、DDDの中で**最も重要な概念**である。

> **ユビキタス言語**: 開発チームとドメインエキスパート（業務の専門家）が共有する、
> **厳密で一貫した共通言語**のこと。
> この言語はコード、会話、ドキュメント、テスト、すべてにおいて使われる。

### なぜ「最も重要」なのか？

他のDDDパターン（Entity, Value Object, Aggregate等）は、
すべて**ユビキタス言語を正しく確立した上で初めて意味を持つ**。

```
ユビキタス言語の位置づけ:

  ユビキタス言語（基盤）
      │
      ├── 戦略的設計パターン
      │   └── 境界づけられたコンテキスト
      │       └── コンテキストマップ
      │
      └── 戦術的設計パターン
          ├── エンティティ
          ├── 値オブジェクト
          └── 集約 ...

  ★ ユビキタス言語が間違っていたら、すべてのパターンが意味をなさない
```

### ユビキタス言語の特徴

1. **チーム全員が同じ言葉を使う**: 開発者もビジネス側も同じ用語を使う
2. **コードに直接反映される**: クラス名、メソッド名、変数名がユビキタス言語そのもの
3. **曖昧さを排除する**: 「ユーザー」のような曖昧な言葉ではなく「会員」「購入者」「出品者」と具体化
4. **継続的に進化する**: ドメインの理解が深まるにつれて言語も洗練される
5. **境界づけられたコンテキストごとに定義される**: 同じ言葉でもコンテキストが違えば意味が異なる

### 具体例: ECサイトの場合

```
❌ 曖昧な言葉（ユビキタス言語ではない）
  • 「ユーザー」 → 誰？ 買う人？ 売る人？ 管理者？
  • 「アイテム」 → 商品？ カート内の項目？ 注文明細？
  • 「処理する」 → 何を？ 注文確定？ 支払い？ 出荷？

✅ ユビキタス言語の例
  • 「購入者（Buyer）」「出品者（Seller）」「管理者（Administrator）」
  • 「商品（Product）」「カート項目（CartItem）」「注文明細（OrderLineItem）」
  • 「注文を確定する（PlaceOrder）」「支払いを処理する（ProcessPayment）」
```

---

## 10. 言葉のズレが引き起こす問題

### よくあるシナリオ

ある ECサイトの開発チームでの会話:

```
【ビジネス側】「注文がキャンセルされた場合、ポイントを戻す必要がある」

【開発者A の理解】
  → order テーブルの status を 'cancelled' に UPDATE
  → point テーブルの value に加算する INSERT

【開発者B の理解】
  → キャンセルって delete_flag を立てること？
  → ポイント戻すって、元のポイント付与レコードを削除？

【実際のビジネスルール】
  → 注文キャンセルにはいくつかの種類がある
    - 出荷前キャンセル: 全額返金 + ポイント全額返還
    - 出荷後キャンセル: 返品確認後に返金 + ポイント返還は保留
    - 部分キャンセル: 明細単位で返金計算
  → 「ポイントを戻す」は新しいポイント付与（種別:返還）として記録
```

### 言葉のズレによる典型的な被害

```
┌─────────────────────────────────────────────────────────┐
│                 言葉のズレの影響                           │
│                                                          │
│  フェーズ1: 要件定義                                      │
│  └─ 曖昧な言葉で合意した「つもり」になる                    │
│                                                          │
│  フェーズ2: 設計・実装                                     │
│  └─ 開発者が独自に解釈してコードを書く                      │
│     （技術用語に置き換えてしまう）                           │
│                                                          │
│  フェーズ3: テスト                                         │
│  └─ 「仕様通り」にテストが通るが、実は認識がズレている        │
│                                                          │
│  フェーズ4: リリース後                                     │
│  └─ ビジネス側「これは違う！」                              │
│     開発側「仕様書通りに作りました」                         │
│     → 手戻り、信頼関係の損失、追加コスト                    │
└─────────────────────────────────────────────────────────┘
```

### コードレベルの問題

言葉のズレは、コード上で以下のような形で現れる:

```python
# ❌ ビジネスの意図が消えたコード
def process(data):
    if data["type"] == 1:       # type=1 って何？
        update_status(data, 9)   # status=9 って何？
        add_record("tbl_point", {"value": data["amount"]})
    elif data["type"] == 2:     # type=2 は？
        update_status(data, 8)   # status=8 は？

# ✅ ユビキタス言語で書かれたコード
def cancel_order(order: Order, cancellation_type: CancellationType):
    if cancellation_type == CancellationType.BEFORE_SHIPMENT:
        order.cancel_with_full_refund()
        point_service.grant_return_points(order)
    elif cancellation_type == CancellationType.AFTER_SHIPMENT:
        order.request_return_inspection()
```

---

## 11. ユビキタス言語の構築と維持

### 構築方法

#### Step 1: ドメインエキスパートとの対話

```
開発者:「この画面で何をするんですか？」
エキスパート:「ここで承認者が稟議を承認するんです」
開発者:「"承認" と "決裁" は同じ意味ですか？」
エキスパート:「いいえ。承認は各段階の上司がOKを出すこと、
              決裁は最終権限者が予算執行を認めることです」
開発者:「なるほど。では "承認(Approval)" と
        "決裁(Authorization)" は別の概念として扱いますね」
```

#### Step 2: 用語集（Glossary）の作成

| 用語（日本語） | 用語（英語/コード） | 定義 | 注意点 |
|---|---|---|---|
| 注文 | Order | 購入者が商品の購入を確定した取引 | 「購入」「買い物」とは言わない |
| 注文明細 | OrderLineItem | 注文内の個々の商品と数量 | 「アイテム」「商品」と混同しない |
| 出荷 | Shipment | 注文に対する物理的な配送 | 1注文に対し複数出荷がありうる |
| 返品 | Return | 購入者からの商品返却 | 「キャンセル」とは異なる |

#### Step 3: コードへの反映

用語集で定義した言葉を**そのまま**クラス名、メソッド名に使う。

```python
class Order:
    """注文: 購入者が商品の購入を確定した取引"""

    def __init__(self, order_id: OrderId, buyer: Buyer, line_items: list[OrderLineItem]):
        self._order_id = order_id
        self._buyer = buyer
        self._line_items = line_items

    def place(self):
        """注文を確定する"""
        ...

    def cancel_before_shipment(self):
        """出荷前キャンセルを行う"""
        ...
```

### 維持方法

ユビキタス言語は**一度作って終わりではない**。以下のプラクティスで維持する。

```
┌─────────────────────────────────────────────────────────┐
│              ユビキタス言語を維持するプラクティス            │
│                                                          │
│  1. コードレビューで言語の一貫性をチェックする               │
│     「この変数名、ユビキタス言語と違いますよ」               │
│                                                          │
│  2. 新しい概念が出たらすぐ用語集を更新する                  │
│     スプリントレトロで用語集レビューの時間を取る              │
│                                                          │
│  3. テストケースの名前にもユビキタス言語を使う               │
│     test_出荷前キャンセルでポイントが全額返還される()         │
│                                                          │
│  4. ドメインエキスパートがコードを「読める」状態を保つ         │
│     完全に理解する必要はないが、クラス名・メソッド名は        │
│     ビジネス側の人が見ても意味がわかること                    │
│                                                          │
│  5. 曖昧な言葉が出たらすぐに立ち止まって定義する             │
│     「それって具体的にどういう意味ですか？」                 │
└─────────────────────────────────────────────────────────┘
```

---

## 12. コード内で言語を体現する

### 言語を体現するとは

「コード内で言語を体現する」とは、**コードを読むことが仕様書を読むことと等価になる**状態を目指すことである。

### 原則

```
┌─────────────────────────────────────────────────────┐
│          コード内で言語を体現する5つの原則              │
│                                                      │
│  1. クラス名はドメインの名詞                           │
│     Order, Product, Member, Shipment                 │
│                                                      │
│  2. メソッド名はドメインの動詞                         │
│     place_order(), cancel(), approve(), ship()       │
│                                                      │
│  3. 引数名もドメイン用語                              │
│     buyer_id（✅）vs user_id（❌）                    │
│     quantity（✅）vs num（❌）                        │
│                                                      │
│  4. 条件分岐はビジネスルールを読み下せるように           │
│     if order.is_cancellable():（✅）                  │
│     if order.status == 3:（❌）                       │
│                                                      │
│  5. 例外もドメインの言葉で                            │
│     raise InsufficientStockError（✅）                │
│     raise ValueError("not enough")（❌）             │
└─────────────────────────────────────────────────────┘
```

### Before / After で見る改善例

**Before（技術中心のコード）:**

```python
def proc(uid, pid, qty):
    u = db.query("SELECT * FROM users WHERE id=?", uid)
    p = db.query("SELECT * FROM products WHERE id=?", pid)
    if p["stock"] >= qty:
        db.execute("UPDATE products SET stock=stock-? WHERE id=?", qty, pid)
        db.execute("INSERT INTO orders (uid, pid, qty, status) VALUES (?,?,?,?)",
                   uid, pid, qty, 1)
        return {"status": "ok"}
    else:
        return {"status": "ng", "error": "stock"}
```

**After（ユビキタス言語で書かれたコード）:**

```python
def place_order(buyer_id: BuyerId, product_id: ProductId, quantity: Quantity) -> Order:
    """購入者が商品を注文する"""
    buyer = buyer_repository.find_by_id(buyer_id)
    product = product_repository.find_by_id(product_id)

    if not product.has_sufficient_stock(quantity):
        raise InsufficientStockError(product_id, quantity)

    order = Order.place(buyer=buyer, product=product, quantity=quantity)
    product.allocate_stock(quantity)

    order_repository.save(order)
    return order
```

**変化のポイント:**

| Before | After | なぜ改善か |
|---|---|---|
| `proc` | `place_order` | 「注文を確定する」という業務がわかる |
| `uid`, `pid` | `buyer_id`, `product_id` | ドメインの概念が明確 |
| `p["stock"] >= qty` | `product.has_sufficient_stock()` | ビジネスルールが読み取れる |
| `status: "ng"` | `InsufficientStockError` | 何が問題なのか明確 |
| 生SQL | Repository パターン | 永続化の詳細が隠蔽される |

> 📁 詳しい例は `examples/ubiquitous_language_example.py` を参照。

---

## 13. まとめ

### 今日学んだこと

```
Day 1 のキーポイント
│
├── DDDは「ドメインの複雑さ」に立ち向かうための手法
│
├── 本質的複雑さ（ドメイン由来）と偶有的複雑さ（技術由来）を区別する
│
├── 技術駆動ではなく、ドメインの言葉を出発点にする
│
├── DDDには戦略的設計と戦術的設計の2つの柱がある
│   └── 戦略的設計（特にユビキタス言語）が最も重要
│
├── ユビキタス言語 = チーム全体の共通言語
│   ├── コード、会話、ドキュメントすべてで統一する
│   ├── 曖昧な言葉を排除する
│   └── 継続的に育てる
│
└── コード = 仕様書 となる状態を目指す
```

### 次のステップ（Day 2 予告）

Day 2 では**「ドメインとサブドメイン」**について学ぶ。
- ビジネスドメインとは何か
- コアドメイン / サポートサブドメイン / 汎用サブドメイン
- ドメインモデリングの最初の一歩

### チェックリスト

Day 1 の内容を理解できたか、以下をセルフチェックしよう:

- [ ] DDDが何を解決しようとしているか説明できる
- [ ] 本質的複雑さと偶有的複雑さの違いを説明できる
- [ ] 技術駆動とドメイン駆動の違いをコードレベルで説明できる
- [ ] ユビキタス言語が何か説明できる
- [ ] なぜユビキタス言語がDDDで最も重要なのか説明できる
- [ ] 戦略的設計と戦術的設計の違いを説明できる
- [ ] exercises.md の演習に取り組んだ

---

## 14. 参考文献

### 必読書

1. **Eric Evans** (2003) "Domain-Driven Design: Tackling Complexity in the Heart of Software"
   - DDDの原典。通称「青い本」
2. **Vaughn Vernon** (2013) "Implementing Domain-Driven Design"
   - DDDの実践的実装ガイド。通称「赤い本」
3. **Vaughn Vernon** (2016) "Domain-Driven Design Distilled"
   - DDDのエッセンスを凝縮した入門書

### 参考論文・記事

4. **Fred Brooks** (1986) "No Silver Bullet - Essence and Accident in Software Engineering"
5. **Brian Foote, Joseph Yoder** (1997) "Big Ball of Mud"
6. **Martin Fowler** - [BoundedContext](https://martinfowler.com/bliki/BoundedContext.html)
7. **Martin Fowler** - [UbiquitousLanguage](https://martinfowler.com/bliki/UbiquitousLanguage.html)

---

> **次回**: [Day 2: ドメインとサブドメイン](../day02/README.md)
