# Day 6: 集約（Aggregate）とリポジトリ（Repository）

> **目標**: 集約の設計原則を理解し、トランザクション境界としての集約を適切に設計できるようになる。リポジトリとファクトリの役割を理解し、実装できるようになる。

---

## 目次

1. [集約（Aggregate）とは何か](#1-集約aggregateとは何か)
2. [集約ルート（Aggregate Root）](#2-集約ルートaggregate-root)
3. [集約の4つの設計原則](#3-集約の4つの設計原則)
4. [集約を大きくしすぎるアンチパターン](#4-集約を大きくしすぎるアンチパターン)
5. [集約境界の見つけ方](#5-集約境界の見つけ方)
6. [リポジトリ（Repository）](#6-リポジトリrepository)
7. [リポジトリのインターフェース設計](#7-リポジトリのインターフェース設計)
8. [リポジトリと DAO の違い](#8-リポジトリと-dao-の違い)
9. [ファクトリ（Factory）](#9-ファクトリfactory)
10. [まとめ](#10-まとめ)

---

## 1. 集約（Aggregate）とは何か

### データ変更の一貫性を保証する境界

Day 5 で学んだエンティティと値オブジェクトは、単体では**ビジネスルール（不変条件）を保証する範囲**が曖昧になる。
例えば「注文の合計金額が上限を超えてはならない」というルールは、`Order` 単体では不十分で、`OrderLine`（注文明細）と一緒に管理しなければならない。

**集約（Aggregate）** とは、**データの変更に関する一貫性（整合性）を保証する境界**のことである。

```
┌─────────────────────────────────────────────────────┐
│              集約（Aggregate）の概念図                   │
│                                                       │
│  ┌─────────────────────────────────────────────┐     │
│  │         集約の境界（一貫性の境界）               │     │
│  │                                               │     │
│  │   ┌───────────────────┐                      │     │
│  │   │  集約ルート          │  ← 外部からの       │     │
│  │   │ （Aggregate Root）  │    唯一のアクセス窓口 │     │
│  │   └─────────┬─────────┘                      │     │
│  │             │                                 │     │
│  │     ┌───────┼───────┐                        │     │
│  │     ▼       ▼       ▼                        │     │
│  │  ┌─────┐ ┌─────┐ ┌─────┐                    │     │
│  │  │ 内部 │ │ 内部 │ │ 値   │                    │     │
│  │  │Entity│ │Entity│ │Object│                    │     │
│  │  └─────┘ └─────┘ └─────┘                    │     │
│  │                                               │     │
│  │  ★ この境界内の不変条件は常に保証される         │     │
│  └─────────────────────────────────────────────┘     │
│                                                       │
└─────────────────────────────────────────────────────┘
```

### 集約の3つの構成要素

| 構成要素 | 説明 | 例（注文集約） |
|---------|------|--------------|
| **集約ルート（Aggregate Root）** | 外部からアクセスできる唯一のエンティティ | `Order` |
| **内部エンティティ** | 集約ルートを通じてのみアクセスされるエンティティ | `OrderLine` |
| **値オブジェクト** | 不変で、属性の組み合わせで同一性を判断するオブジェクト | `Money`, `Quantity` |

### なぜ集約が必要なのか？

集約がない場合、以下の問題が起きる:

```
❌ 集約のない世界:

  外部のコード（サービス層など）
     │
     ├── Order を直接操作
     ├── OrderLine を直接操作   ← 不整合の原因！
     └── Money を直接操作

  → Order と OrderLine の整合性を「呼び出し側」が保証しなければならない
  → ルールがコードの至る所に散らばる
  → バグの温床

✅ 集約のある世界:

  外部のコード（サービス層など）
     │
     └── Order（集約ルート）のメソッドを呼ぶ
           │
           └── Order 内部で OrderLine と Money の
               整合性を自ら保証する

  → ビジネスルールが1箇所に集約される
  → 外部は Order のメソッドだけ知っていればよい
```

---

## 2. 集約ルート（Aggregate Root）

### 集約ルートの責務

集約ルートは、集約全体の**門番（Gatekeeper）** である。

```
┌────────────────────────────────────────────────────┐
│                                                      │
│   外部の世界（アプリケーションサービス、他の集約）       │
│                                                      │
│        │  order.add_item(...)   ✅ OK               │
│        │  order.cancel()        ✅ OK               │
│        │                                            │
│        ▼                                            │
│   ╔════════════════════════════════════╗            │
│   ║      Order（集約ルート）            ║            │
│   ║                                    ║            │
│   ║  ┌──────────┐  ┌──────────┐       ║            │
│   ║  │OrderLine │  │OrderLine │ ...   ║            │
│   ║  └──────────┘  └──────────┘       ║            │
│   ║                                    ║            │
│   ║  不変条件:                          ║            │
│   ║  - 明細は1つ以上                    ║            │
│   ║  - 合計金額 ≧ 0                    ║            │
│   ║  - キャンセルは確定前のみ            ║            │
│   ╚════════════════════════════════════╝            │
│                                                      │
│        ✗  order_line.change_quantity(5)  ❌ NG      │
│        ✗  外部から OrderLine を直接操作    ❌ NG      │
│                                                      │
└────────────────────────────────────────────────────┘
```

### 集約ルートの5つのルール

1. **外部からのアクセスは集約ルートのメソッド経由のみ**
   - 内部エンティティを外部に公開しない（公開しても読み取り専用）
2. **集約内の不変条件を守る**
   - 不正な状態にならないように、すべての操作でチェックする
3. **トランザクション境界 = 集約境界**
   - 1つのトランザクションで1つの集約のみを変更する
4. **集約ルートはグローバルに一意な ID を持つ**
   - 内部エンティティはローカルな ID でよい
5. **ドメインイベントは集約ルートから発行する**
   - 内部の変更を外部に通知する窓口としての役割

```python
# ❌ アンチパターン: 内部エンティティを外部から直接操作
order = order_repository.find_by_id(order_id)
line = order.lines[0]       # 内部エンティティを取得
line.quantity = 10           # 直接変更 → 不変条件チェックが行われない！

# ✅ 正しいパターン: 集約ルート経由で操作
order = order_repository.find_by_id(order_id)
order.change_item_quantity(  # 集約ルートのメソッドを呼ぶ
    line_id=line_id,
    new_quantity=10           # 内部で不変条件がチェックされる
)
```

---

## 3. 集約の4つの設計原則

Vaughn Vernon の「実践ドメイン駆動設計」で提唱された4つの原則を解説する。

### 原則1: 真の不変条件を集約境界内に閉じ込める

**不変条件（Invariant）** とは、「常に満たされていなければならないビジネスルール」のこと。

```
質問: その不変条件は、リアルタイムに保証する必要があるか？

  YES（トランザクション整合性が必要）
    → 同じ集約の中に入れる

  NO（少し遅れてもビジネス上問題ない）
    → 結果整合性で対応（別の集約にする）
```

**例: ECサイトの注文**

```
┌───────────────────────────────────────────────┐
│ 「注文」集約の不変条件:                           │
│                                                 │
│ 1. 注文明細は1つ以上必要                         │
│    → 即座に保証が必要 → 集約内に閉じ込める       │
│                                                 │
│ 2. 合計金額は上限（100万円）以下                  │
│    → 即座に保証が必要 → 集約内に閉じ込める       │
│                                                 │
│ 3. 在庫があること                               │
│    → 注文時点では引き当て、在庫不足は             │
│      後から調整可能（結果整合性でOK）             │
│    → 別の集約（在庫集約）として分離              │
│                                                 │
│ 4. 顧客の与信枠内であること                      │
│    → 注文時にチェックするが、超過は               │
│      後から調整可能（結果整合性でOK）             │
│    → 別の集約（顧客集約）として分離              │
└───────────────────────────────────────────────┘
```

### 原則2: 小さな集約を設計する

大きな集約は以下の問題を引き起こす:

```
大きな集約                          小さな集約
┌─────────────────────┐          ┌─────────────┐
│       Order          │          │    Order     │
│  ├── OrderLine[]     │          │  ├── lines[] │
│  ├── Customer        │          │  └── status  │
│  ├── Payment         │          └─────────────┘
│  ├── Shipping        │
│  ├── Invoice         │          ┌─────────────┐
│  └── Review[]        │          │   Payment    │
└─────────────────────┘          │  └── amount  │
                                  └─────────────┘
❌ 問題:
- 同時実行時の競合が多発                ┌─────────────┐
- メモリ消費が大きい                    │  Shipping    │
- ロードに時間がかかる                  │  └── status  │
- 関係ないデータの変更で                └─────────────┘
  ロックがかかる
                                  ✅ メリット:
                                  - 競合が少ない
                                  - パフォーマンスが良い
                                  - 各集約が独立して変更可能
```

**ガイドライン**: 集約は「集約ルート + 値オブジェクト数個」が理想。
内部エンティティは本当に必要な場合のみ。

### 原則3: 他の集約への参照は ID のみで持つ

```python
# ❌ アンチパターン: オブジェクト参照で他の集約を持つ
class Order:
    def __init__(self):
        self.customer: Customer = ...    # Customer 集約の参照
        self.products: list[Product] = ...  # Product 集約の参照

    # 問題: Order を保存するとき Customer も一緒に保存される？
    # 問題: Customer を変更すると Order にも影響する？
    # 問題: 遅延ロード？ → インフラ層の関心がドメインに漏れる

# ✅ 正しいパターン: ID で参照する
class Order:
    def __init__(self):
        self.customer_id: CustomerId = ...     # ID のみ
        self.product_ids: list[ProductId] = ... # ID のみ

    # メリット: 集約同士が完全に独立
    # メリット: 永続化の戦略が自由
    # メリット: マイクロサービス化しやすい
```

```
 ID参照による集約間の関係

 ┌──────────────┐         ┌──────────────┐
 │    Order      │         │   Customer   │
 │               │  ID参照  │              │
 │ customer_id ──┼────────→│  id          │
 │               │         │  name        │
 │ lines[]       │         │  rank        │
 └──────────────┘         └──────────────┘
        │
        │ ID参照
        ▼
 ┌──────────────┐
 │   Product     │
 │               │
 │  id           │
 │  name         │
 │  price        │
 └──────────────┘

 ※ 矢印はオブジェクト参照ではなく「IDで知っている」関係
```

### 原則4: 結果整合性を受け入れる

**即時整合性（Strong Consistency）** と **結果整合性（Eventual Consistency）** の違い:

```
即時整合性:
  「注文確定」と「在庫引当」が同一トランザクションで完了
  → 1つのトランザクションで複数の集約を変更

  ❌ 問題: 集約が密結合になる、パフォーマンス低下

結果整合性:
  「注文確定」→ ドメインイベント発行 → 「在庫引当」
  → 別々のトランザクションで各集約を変更

  ✅ メリット: 集約が独立、スケーラブル
```

```
結果整合性の流れ:

  ┌──────────┐   OrderPlaced    ┌──────────────┐
  │  Order    │  ──イベント──→   │  Inventory    │
  │ (集約1)   │                  │  (集約2)      │
  │           │                  │               │
  │ confirm() │                  │ reserve()     │
  └──────────┘                  └──────────────┘
       │                              │
   トランザクション1              トランザクション2
   (注文を確定)                (在庫を引き当て)

  ※ 2つのトランザクションは別々に実行される
  ※ 一時的に不整合な状態が存在するが、最終的に整合する
```

**ビジネスエキスパートに聞くべき質問**:
- 「注文確定と在庫引当の間に数秒のタイムラグがあっても問題ないですか？」
- 多くの場合、答えは「問題ない」→ 結果整合性で十分

---

## 4. 集約を大きくしすぎるアンチパターン

### 「God Aggregate」アンチパターン

最も多い間違いは、関連するものをすべて1つの集約に入れてしまうこと。

```
❌ God Aggregate（巨大な注文集約）:

┌────────────────────────────────────────────┐
│                 Order                        │
│                                              │
│  ├── customer: Customer                      │
│  │     ├── name                              │
│  │     ├── email                             │
│  │     ├── addresses: list[Address]           │
│  │     └── payment_methods: list[PaymentMethod]│
│  │                                            │
│  ├── lines: list[OrderLine]                   │
│  │     ├── product: Product                   │
│  │     │     ├── name                         │
│  │     │     ├── description                  │
│  │     │     ├── category: Category           │
│  │     │     └── reviews: list[Review]        │
│  │     └── quantity                           │
│  │                                            │
│  ├── payment: Payment                         │
│  │     ├── method                             │
│  │     ├── amount                             │
│  │     └── transaction_logs: list[Log]        │
│  │                                            │
│  ├── shipping: Shipping                       │
│  │     ├── address                            │
│  │     ├── carrier                            │
│  │     └── tracking_events: list[Event]       │
│  │                                            │
│  └── invoice: Invoice                         │
│        ├── billing_address                    │
│        └── tax_details                        │
│                                              │
│  → メモリ消費: 巨大                            │
│  → ロック範囲: 広すぎ                          │
│  → 変更理由: 多すぎ（SRP違反）                 │
└────────────────────────────────────────────┘
```

```
✅ 適切に分割された集約群:

┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│    Order     │  │   Customer  │  │   Product   │
│  order_id    │  │ customer_id │  │ product_id  │
│  customer_id │  │ name        │  │ name        │
│  lines[]     │  │ email       │  │ price       │
│  status      │  │ rank        │  │ category_id │
└─────────────┘  └─────────────┘  └─────────────┘

┌─────────────┐  ┌─────────────┐
│   Payment   │  │  Shipment   │
│ payment_id  │  │ shipment_id │
│ order_id    │  │ order_id    │
│ amount      │  │ status      │
│ method      │  │ tracking_no │
└─────────────┘  └─────────────┘

→ 各集約が独立してロード・保存・変更可能
→ 並行操作時の競合が最小限
→ それぞれ異なる理由・タイミングで変更される
```

### 判断基準: 「これは同じトランザクションで変更する必要があるか？」

| 操作 | 同じトランザクション？ | 理由 |
|------|---------------------|------|
| 注文に商品を追加 + 合計金額の再計算 | ✅ YES | 合計金額の不変条件を守る必要がある |
| 注文の確定 + 在庫の引当 | ❌ NO | 結果整合性で十分 |
| 注文の確定 + 決済の実行 | ❌ NO | 結果整合性で十分（Sagaパターン） |
| 顧客名の変更 + 注文の更新 | ❌ NO | 注文は注文時点のスナップショットを持つ |

---

## 5. 集約境界の見つけ方

### 5つのヒューリスティクス

#### ヒューリスティクス1: 不変条件から考える

```
手順:
  1. ドメインエキスパートに「絶対に守らなければならないルール」を聞く
  2. そのルールに関わるデータを1つの集約にまとめる
  3. 関わらないデータは別の集約にする

例:
  ルール「注文の合計金額は100万円以下」
    → Order と OrderLine は同じ集約
    → Customer の残高は関係ない → 別の集約
```

#### ヒューリスティクス2: ライフサイクルから考える

```
手順:
  1. オブジェクトが「生まれてから消えるまで」のライフサイクルを考える
  2. 同じライフサイクルを持つ → 同じ集約
  3. 独立したライフサイクルを持つ → 別の集約

例:
  OrderLine は Order とともに生まれ、Order とともに消える
    → 同じ集約

  Product は Order とは独立して存在する
    → 別の集約
```

#### ヒューリスティクス3: 同時変更の頻度から考える

```
手順:
  1. いつも一緒に変更されるデータ → 同じ集約
  2. 別々のタイミングで変更されるデータ → 別の集約

例:
  注文明細の追加 → Order と OrderLine は常に一緒に変更
    → 同じ集約

  商品の価格変更 → Product のみ変更、既存の Order は変わらない
    → 別の集約
```

#### ヒューリスティクス4: ドメインエキスパートの言葉に注目する

```
ドメインエキスパートが「〜の中の〜」と言ったら、
集約の構造が見えてくる。

  「注文の中の明細行を変更したい」
    → Order が集約ルート、OrderLine は内部エンティティ

  「この顧客の注文を見せて」
    → Customer と Order は別の集約（「の中の」ではなく「の」）
```

#### ヒューリスティクス5: 並行アクセスの視点から考える

```
  「複数のユーザーが同時にこのデータを変更する可能性は？」

  低い（通常1人のユーザーが操作する）
    → 集約に含めてもOK

  高い（多数のユーザーが同時に操作する）
    → 競合を避けるため別の集約にする

例:
  「1つの注文」 → 操作するのは通常1人 → 集約内のデータはまとめてOK
  「商品の在庫数」 → 大量の注文で同時に更新される → 注文とは別の集約に
```

---

## 6. リポジトリ（Repository）

### リポジトリとは何か

**リポジトリ（Repository）** は、集約の永続化（保存）と取得（検索）を担当する。
ドメイン層から見ると、リポジトリは「**集約のコレクション**」のように振る舞う。

```
┌──────────────────────────────────────────────────┐
│                                                    │
│  ドメイン層の視点:                                   │
│                                                    │
│  OrderRepository は「Order のコレクション」           │
│  のように見える                                      │
│                                                    │
│    orders = repository.find_by_customer_id(...)    │
│    repository.save(order)                          │
│                                                    │
│  → データベースの存在を意識しない                     │
│  → SQL や ORM の詳細は知らない                       │
│  → まるで「メモリ上のリストに入れる」感覚              │
│                                                    │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│                                                    │
│  インフラ層の実装:                                   │
│                                                    │
│  実際には RDB, NoSQL, ファイル等に保存する            │
│                                                    │
│    class SqlOrderRepository(OrderRepository):      │
│        def save(self, order):                      │
│            # INSERT/UPDATE SQL を実行              │
│                                                    │
│        def find_by_id(self, order_id):             │
│            # SELECT SQL を実行                     │
│            # 結果を Order 集約に再構築               │
│                                                    │
└──────────────────────────────────────────────────┘
```

### コレクション指向 vs 永続化指向

リポジトリの実装スタイルには2つの流派がある。

```
【コレクション指向リポジトリ】

  Java の Set や List のようなインターフェース
  追加（add）、削除（remove）が基本操作
  変更は「取得 → 変更 → 自動保存」（Unit of Work パターン）

  repository.add(order)           # 追加
  order = repository.find_by_id(id)
  order.cancel()                   # メモリ上で変更
  # → トランザクション終了時に自動的に永続化

  ✅ メリット: ドメインコードがシンプル
  ❌ デメリット: ORM（SQLAlchemy 等）に依存しやすい


【永続化指向リポジトリ】

  明示的に save() を呼んで保存する
  追加も更新も save() で統一

  repository.save(order)           # 追加
  order = repository.find_by_id(id)
  order.cancel()                   # メモリ上で変更
  repository.save(order)           # 明示的に保存

  ✅ メリット: 明示的でわかりやすい、ORM非依存
  ❌ デメリット: save() の呼び忘れリスク
```

> **推奨**: Python では**永続化指向リポジトリ**が扱いやすい。
> 明示的な `save()` のほうがコードの意図が伝わりやすく、
> インフラ層の選択肢も広い。

### リポジトリは集約ルート単位で1つ

```
✅ 正しい: 集約ルートに対して1つのリポジトリ

  Order（集約ルート）     → OrderRepository
  Customer（集約ルート）  → CustomerRepository
  Product（集約ルート）   → ProductRepository

❌ 間違い: 内部エンティティや値オブジェクトにリポジトリを作る

  OrderLine（内部Entity）  → OrderLineRepository  ❌
  Money（値オブジェクト）   → MoneyRepository       ❌

  → OrderLine は Order を通じてのみ永続化される
  → リポジトリは必ず集約全体を保存・取得する
```

```
 リポジトリの保存単位

 ┌─────────────────────────────────────┐
 │          OrderRepository             │
 │                                      │
 │  save(order) で以下を「まとめて」保存:  │
 │                                      │
 │  ┌─────────────────────────────┐    │
 │  │         Order                │    │
 │  │  ┌──────────┐ ┌──────────┐  │    │
 │  │  │OrderLine │ │OrderLine │  │    │
 │  │  │(明細1)   │ │(明細2)   │  │    │
 │  │  └──────────┘ └──────────┘  │    │
 │  │                              │    │
 │  │  OrderId, Money, Status      │    │
 │  └─────────────────────────────┘    │
 │                                      │
 │  → 集約全体を1つの単位として          │
 │    保存・取得する                      │
 └─────────────────────────────────────┘
```

---

## 7. リポジトリのインターフェース設計

### 基本のインターフェース

リポジトリのインターフェースは**ドメイン層**に定義し、
実装は**インフラ層**に置く（依存関係逆転の原則: DIP）。

```
ディレクトリ構成:

src/
├── domain/                      ← ドメイン層
│   ├── model/
│   │   └── order/
│   │       ├── order.py          ← 集約ルート
│   │       └── order_line.py     ← 内部エンティティ
│   └── repository/
│       └── order_repository.py   ← インターフェース（抽象クラス）
│
└── infrastructure/               ← インフラ層
    └── persistence/
        ├── in_memory_order_repository.py  ← InMemory 実装
        └── sql_order_repository.py        ← SQL 実装
```

```
依存の方向:

  ┌─────────────────────────┐
  │   Application Layer      │
  │                          │
  │  PlaceOrderUseCase       │
  │    │                     │
  │    │ 依存                │
  │    ▼                     │
  │  OrderRepository         │ ← インターフェース（domain層）
  └─────────────────────────┘
              ▲
              │ 実装
  ┌───────────┴─────────────┐
  │   Infrastructure Layer   │
  │                          │
  │  InMemoryOrderRepository │ ← 具象クラス（infra層）
  │  SqlOrderRepository      │
  └─────────────────────────┘

  ★ ドメイン層はインフラ層を知らない
  ★ インフラ層がドメイン層のインターフェースを実装する
```

### ドメインセマンティクスを持つメソッド名

リポジトリのメソッド名は、**CRUD用語ではなく、ドメインの言葉**で表現する。

```python
# ❌ CRUD的なリポジトリ（DAO的）
class OrderRepository:
    def insert(self, order): ...
    def update(self, order): ...
    def delete(self, order_id): ...
    def select_by_id(self, order_id): ...
    def select_all(self): ...

# ✅ ドメインセマンティクスを持つリポジトリ
class OrderRepository:
    def save(self, order): ...                    # 保存（追加も更新も）
    def find_by_id(self, order_id): ...           # IDで検索
    def find_by_customer_id(self, customer_id): ... # 顧客IDで検索
    def find_pending_orders(self): ...            # 未確定の注文を検索
    def remove(self, order): ...                  # 削除（論理削除も含む）
    def next_identity(self) -> OrderId: ...       # 新しいIDを生成
```

### 返り値の型の設計

```python
from abc import ABC, abstractmethod
from typing import Optional

class OrderRepository(ABC):
    @abstractmethod
    def find_by_id(self, order_id: OrderId) -> Optional[Order]:
        """見つからない場合は None を返す"""
        ...

    @abstractmethod
    def find_by_customer_id(self, customer_id: CustomerId) -> list[Order]:
        """該当する注文のリストを返す（0件ならば空リスト）"""
        ...

    @abstractmethod
    def save(self, order: Order) -> None:
        """集約全体を永続化する"""
        ...
```

---

## 8. リポジトリと DAO の違い

リポジトリと DAO（Data Access Object）は混同されがちだが、根本的に異なる。

```
┌───────────────────────┬────────────────────────────┐
│      リポジトリ         │           DAO               │
├───────────────────────┼────────────────────────────┤
│ ドメイン層の概念        │ インフラ層の概念              │
│                        │                             │
│ 集約全体を扱う          │ テーブル/行を扱う             │
│                        │                             │
│ ドメインの言葉を使う    │ CRUD の言葉を使う             │
│ (save, find_by_xxx)   │ (insert, update, delete)    │
│                        │                             │
│ 集約ルートごとに1つ    │ テーブルごとに1つ             │
│                        │                             │
│ ドメインモデルを返す    │ データ構造(DTO/dict)を返す    │
│                        │                             │
│ 永続化の詳細を隠蔽     │ SQL/NoQL の薄いラッパー       │
└───────────────────────┴────────────────────────────┘
```

```
具体例で比較:

【DAO の場合】
  orders_dao.insert(order_row)          # ordersテーブルに1行追加
  order_lines_dao.insert(line_row)      # order_linesテーブルに1行追加
  order_lines_dao.insert(line_row2)     # order_linesテーブルに1行追加
  → 3回のDB操作を呼び出し側が管理

【リポジトリの場合】
  order_repository.save(order)          # 集約全体を1回で保存
  → 内部で orders テーブルと order_lines テーブルの
    両方を適切に保存する（呼び出し側は知らない）
```

> **重要**: リポジトリの内部実装として DAO を使うことは問題ない。
> しかしドメイン層から見えるインターフェースは「リポジトリ」であるべき。

---

## 9. ファクトリ（Factory）

### ファクトリとは何か

**ファクトリ（Factory）** は、集約やエンティティなど、複雑なオブジェクトの生成をカプセル化するパターン。

```
なぜファクトリが必要か？

  集約の生成には以下の処理が必要:
  1. ID の生成
  2. 初期状態の設定
  3. 不変条件のチェック
  4. 内部オブジェクトの組み立て
  5. ドメインイベントの記録

  → これらの複雑なロジックを集約のコンストラクタに
    すべて詰め込むと、コンストラクタが肥大化する
  → ファクトリに切り出すことでスッキリする
```

### ファクトリメソッド vs ファクトリクラス

```
【パターン1: ファクトリメソッド】

  集約ルート自身にクラスメソッドとして定義する。
  生成ロジックがシンプルな場合に適している。

  class Order:
      @classmethod
      def create(cls, customer_id, items) -> "Order":
          order = cls(...)
          order._record_event(OrderCreated(...))
          return order

  order = Order.create(customer_id, items)


【パターン2: ファクトリクラス】

  独立したファクトリクラスを定義する。
  生成ロジックが複雑な場合や、外部データが必要な場合に適している。

  class OrderFactory:
      def create_from_cart(self, cart, customer_id) -> Order:
          # カートから注文を生成する複雑なロジック
          ...

      def reconstruct(self, data: dict) -> Order:
          # 永続化データから集約を再構築する
          ...

  factory = OrderFactory()
  order = factory.create_from_cart(cart, customer_id)
```

### 新規作成と再構築の区別

ファクトリには2つの主要なユースケースがある:

```
┌─────────────────────────────────────────────────────┐
│                                                       │
│  1. 新規作成（Creation）                                │
│     - ユーザーの操作によって新しい集約が生まれる         │
│     - ID が新たに発番される                             │
│     - 初期状態が設定される                               │
│     - ドメインイベント（例: OrderCreated）が記録される   │
│                                                       │
│  2. 再構築（Reconstitution）                            │
│     - データベースから読み込んだデータで集約を再現する    │
│     - 既存の ID を使う                                   │
│     - ドメインイベントは記録しない                        │
│     - バリデーションは最小限（データは信頼できる前提）    │
│                                                       │
│  ★ この2つを区別することが重要！                        │
│    新規作成時のルールを再構築時に適用すると、              │
│    過去のデータが読み込めなくなる等の問題が起きる         │
│                                                       │
└─────────────────────────────────────────────────────┘
```

```python
class OrderFactory:
    """注文集約のファクトリ"""

    def create_new_order(self, customer_id: str, items: list) -> Order:
        """新規注文を作成する"""
        order_id = OrderId.generate()        # 新しいIDを生成
        order = Order(order_id, customer_id)
        for item in items:
            order.add_item(item)             # 不変条件がチェックされる
        # ドメインイベントを記録
        order._record_event(OrderCreated(order_id))
        return order

    def reconstruct(self, data: dict) -> Order:
        """永続化データから注文を再構築する（リポジトリが使用）"""
        order = Order.__new__(Order)          # コンストラクタをバイパス
        order._id = OrderId(data["id"])
        order._status = OrderStatus(data["status"])
        order._lines = [...]                  # データからそのまま復元
        # ★ ドメインイベントは記録しない
        # ★ バリデーションは不要（DBのデータを信頼）
        return order
```

---

## 10. まとめ

### 今日学んだこと

1. **集約（Aggregate）** を理解した
   - データ変更の一貫性を保証する境界
   - 集約ルートが外部からの唯一のアクセス窓口
   - 不変条件を集約境界内に閉じ込める

2. **集約の4つの設計原則** を学んだ
   - 真の不変条件を集約内に閉じ込める
   - 小さな集約を設計する
   - 他の集約への参照は ID のみ
   - 結果整合性を受け入れる

3. **リポジトリ（Repository）** を理解した
   - 集約の永続化と取得を担当
   - 集約ルート単位で1つ
   - ドメインセマンティクスを持つインターフェース
   - DAO との違いを理解した

4. **ファクトリ（Factory）** を理解した
   - 複雑なオブジェクト生成のカプセル化
   - 新規作成と再構築の区別が重要

### 次のステップ

- [exercises.md](./exercises.md) の演習に取り組む
- [examples/](./examples/) のコード例を読んで理解を深める
  - [aggregate.py](./examples/aggregate.py): 注文集約の完全な実装
  - [repository.py](./examples/repository.py): リポジトリパターンの実装
  - [factory.py](./examples/factory.py): ファクトリパターンの実装

---

## 参考文献

- Evans, E. (2003). *Domain-Driven Design: Tackling Complexity in the Heart of Software*
  - 特に Chapter 6: The Life Cycle of a Domain Object
- Vernon, V. (2013). *Implementing Domain-Driven Design*
  - 特に Chapter 10: Aggregates, Chapter 12: Repositories
- Vernon, V. (2011). *Effective Aggregate Design* (3部作の論文)
  - Part 1: Modeling a Single Aggregate
  - Part 2: Making Aggregates Work Together
  - Part 3: Gaining Insight Through Discovery
- 成瀬允宣 (2020). *ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本*
  - 特に Chapter 7-9: 集約、リポジトリ

---

> **Day 7 予告**: 「ドメインイベント、仕様パターン、アーキテクチャ」—
> 集約間の連携をドメインイベントで実現する方法、複雑な条件を仕様パターンで表現する方法、
> DDDにおけるアーキテクチャの配置を学ぶ。
